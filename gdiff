diff --git a/components/compiler/README.md b/claude/docs/components/bk_components/compiler/README.md
similarity index 100%
rename from components/compiler/README.md
rename to claude/docs/components/bk_components/compiler/README.md
diff --git a/components/compiler/api/interfaces.md b/claude/docs/components/bk_components/compiler/api/interfaces.md
similarity index 100%
rename from components/compiler/api/interfaces.md
rename to claude/docs/components/bk_components/compiler/api/interfaces.md
diff --git a/components/compiler/spec/requirements.md b/claude/docs/components/bk_components/compiler/spec/requirements.md
similarity index 100%
rename from components/compiler/spec/requirements.md
rename to claude/docs/components/bk_components/compiler/spec/requirements.md
diff --git a/components/evaluator/README.md b/claude/docs/components/bk_components/evaluator/README.md
similarity index 100%
rename from components/evaluator/README.md
rename to claude/docs/components/bk_components/evaluator/README.md
diff --git a/components/evaluator/api/interfaces.md b/claude/docs/components/bk_components/evaluator/api/interfaces.md
similarity index 100%
rename from components/evaluator/api/interfaces.md
rename to claude/docs/components/bk_components/evaluator/api/interfaces.md
diff --git a/components/evaluator/impl/design.md b/claude/docs/components/bk_components/evaluator/impl/design.md
similarity index 100%
rename from components/evaluator/impl/design.md
rename to claude/docs/components/bk_components/evaluator/impl/design.md
diff --git a/components/evaluator/spec/types.md b/claude/docs/components/bk_components/evaluator/spec/types.md
similarity index 100%
rename from components/evaluator/spec/types.md
rename to claude/docs/components/bk_components/evaluator/spec/types.md
diff --git a/components/handler/README.md b/claude/docs/components/bk_components/handler/README.md
similarity index 100%
rename from components/handler/README.md
rename to claude/docs/components/bk_components/handler/README.md
diff --git a/components/handler/impl/provider-integration.md b/claude/docs/components/bk_components/handler/impl/provider-integration.md
similarity index 100%
rename from components/handler/impl/provider-integration.md
rename to claude/docs/components/bk_components/handler/impl/provider-integration.md
diff --git a/components/handler/impl/resource-tracking.md b/claude/docs/components/bk_components/handler/impl/resource-tracking.md
similarity index 100%
rename from components/handler/impl/resource-tracking.md
rename to claude/docs/components/bk_components/handler/impl/resource-tracking.md
diff --git a/components/handler/spec/behaviors.md b/claude/docs/components/bk_components/handler/spec/behaviors.md
similarity index 100%
rename from components/handler/spec/behaviors.md
rename to claude/docs/components/bk_components/handler/spec/behaviors.md
diff --git a/components/handler/spec/interfaces.md b/claude/docs/components/bk_components/handler/spec/interfaces.md
similarity index 100%
rename from components/handler/spec/interfaces.md
rename to claude/docs/components/bk_components/handler/spec/interfaces.md
diff --git a/components/handler/spec/types.md b/claude/docs/components/bk_components/handler/spec/types.md
similarity index 100%
rename from components/handler/spec/types.md
rename to claude/docs/components/bk_components/handler/spec/types.md
diff --git a/components/index.md b/claude/docs/components/bk_components/index.md
similarity index 100%
rename from components/index.md
rename to claude/docs/components/bk_components/index.md
diff --git a/components/memory/README.md b/claude/docs/components/bk_components/memory/README.md
similarity index 100%
rename from components/memory/README.md
rename to claude/docs/components/bk_components/memory/README.md
diff --git a/claude/docs/components/memory/api/interfaces.md b/claude/docs/components/bk_components/memory/api/interfaces.md
similarity index 100%
rename from claude/docs/components/memory/api/interfaces.md
rename to claude/docs/components/bk_components/memory/api/interfaces.md
diff --git a/components/memory/spec/types.md b/claude/docs/components/bk_components/memory/spec/types.md
similarity index 100%
rename from components/memory/spec/types.md
rename to claude/docs/components/bk_components/memory/spec/types.md
diff --git a/components/task-system/README.md b/claude/docs/components/bk_components/task-system/README.md
similarity index 100%
rename from components/task-system/README.md
rename to claude/docs/components/bk_components/task-system/README.md
diff --git a/claude/docs/components/task-system/api/interfaces.md b/claude/docs/components/bk_components/task-system/api/interfaces.md
similarity index 100%
rename from claude/docs/components/task-system/api/interfaces.md
rename to claude/docs/components/bk_components/task-system/api/interfaces.md
diff --git a/claude/docs/components/task-system/impl/design.md b/claude/docs/components/bk_components/task-system/impl/design.md
similarity index 74%
rename from claude/docs/components/task-system/impl/design.md
rename to claude/docs/components/bk_components/task-system/impl/design.md
index d754270..3233a3f 100644
--- a/claude/docs/components/task-system/impl/design.md
+++ b/claude/docs/components/bk_components/task-system/impl/design.md
@@ -2,10 +2,11 @@
 
 ## Terminology and References
 
- - **Handler** and **Evaluator** definitions are standardized in [spec/types.md](../spec/types.md).
- - XML schema definitions are available in [system/contracts/protocols.md](../system/contracts/protocols.md).
+ - **Handler** and **Evaluator** definitions are standardized in [Type:TaskSystem:Types:1.0] (../spec/types.md).
+ - XML schema definitions are available in [Contract:Tasks:TemplateSchema:1.0] (../../../system/contracts/protocols.md).
  - For detailed resource tracking implementation (including turn counter and context window monitoring), see [resource-management.md](./resource-management.md).
  - For XML processing details (parsing, validation, and fallback behavior), refer to [xml-processing.md](./xml-processing.md).
+ - For implementation examples, see the [examples/](./examples/) directory.
 
 ## Handler Implementation
 
@@ -31,52 +32,35 @@
 - Session constructs payload via constructPayload() method
 - Full conversation history included in structured format
 
-### Error Propagation Design
-- Standard error type system
-- Immediate propagation on detection
-- Clean resource release
-- No retry attempt handling
-- Complete error context preservation
-
-### Interactive Session Support
-- Input detection capabilities
-- Agent-controlled input requests
-- Resource tracking during interaction
-- Input timeout handling
-- Cancellation support
-
-## Template Management
-### Storage Implementation
-- XML file-based storage
-- Disk-based persistence
-- Directory organization by type
-- Template versioning support
-- Schema validation enforcement
-  
-### Validation Implementation
-- Basic XML structure validation
-- Schema conformance checking
-- Warning generation for issues
-- Template field validation
-- Model availability checking
-  
-### Matching Algorithm Design
-- Scoring based on prompt results
-- Top-N candidate selection
-- Separate matching for human input vs AST
-- Score normalization
-- Clear ordering requirements
-  
-### XML Processing Details
-- Lenient parsing with fallback
-- Warning collection
-- Graceful degradation
-- Partial parsing support
-- Clear error locations
+## Task Template Matching
 
-## Context Management Implementation
+Template matching is a selection process that occurs before and separate from execution:
+
+- **Selection Process**: Matches natural language task descriptions to appropriate atomic task templates
+- **Scoring Mechanism**: Uses associative matching to compute similarity scores
+- **Context Awareness**: May use task context to improve matching accuracy
+- **No Execution Connection**: Completely separate from execution environment or variable binding
+- **Scope Limitation**: Applies only to atomic task templates, not composite task templates
+
+Template matching exclusively answers "which atomic task template should handle this task?" and has no role in variable resolution or execution. While the TaskLibrary can store templates for any task type (atomic, sequential, reduce, etc.), only atomic task templates participate in the template matching process.
+
+### Template Substitution Process
+
+The system implements a standardized template substitution process in the Evaluator component, which resolves `{{variable_name}}` placeholders before dispatching tasks to the Handler:
+
+#### Function-Based Templates
+- For templates with declared parameters (`<template name="example" params="param1,param2">`):
+- Substitution is limited to only the declared parameters
+- The template has no access to other variables in the parent scope
+- Example: `<description>Process {{param1}} with {{param2}}</description>`
+
+#### Standard Templates
+- For templates without explicit parameter declarations:
+- Substitution uses variables from the current lexical environment
+- Variables are resolved through the Environment.find() method
+- Example: `<description>Process {{data_file}} with {{options}}</description>`
 
-### Hybrid Configuration Approach
+## Context Management Implementation
 
 The Task System implements a hybrid configuration approach with operator-specific defaults and explicit overrides:
 
@@ -130,151 +114,63 @@ const DEFAULT_CONTEXT_SETTINGS = {
   }
 };
 
-// File Path Processing
-function processFilePaths(task: TaskDefinition, context: TaskContext): Promise<TaskContext> {
-  if (!task.file_paths || task.file_paths.length === 0) {
-    return Promise.resolve(context);
-  }
-  
-  return fetchAndAddFiles(task.file_paths, context);
-}
+## Function Call Processing
 
-async function fetchAndAddFiles(filePaths: string[], context: TaskContext): Promise<TaskContext> {
-  const fileContents: Array<{path: string, content: string}> = [];
-  const warnings: string[] = [];
-  
-  // Process each file path
-  for (const path of filePaths) {
-    try {
-      // Resolve relative paths to absolute
-      const absolutePath = resolvePath(path);
-      
-      // Fetch file content using Handler tools
-      const content = await handler.tools.readFile(absolutePath);
-      
-      fileContents.push({ path: absolutePath, content });
-    } catch (error) {
-      warnings.push(`Warning: Failed to read file ${path}: ${error.message}`);
-    }
-  }
-  
-  // Format file contents with XML tags
-  const formattedContent = fileContents.map(fc => 
-    `<file path="${fc.path}">\n${fc.content}\n</file>`
-  ).join('\n\n');
-  
-  // Add to context
-  const enhancedContext = {
-    ...context,
-    fileContent: (context.fileContent || '') + formattedContent
-  };
-  
-  // Store warnings
-  if (warnings.length > 0) {
-    enhancedContext.warnings = (enhancedContext.warnings || []).concat(warnings);
-  }
-  
-  return enhancedContext;
-}
+Function calls use direct parameter passing with lexical isolation:
 
-function resolvePath(path: string): string {
-  if (path.startsWith('/')) {
-    // Already absolute
-    return path;
-  }
-  
-  // Resolve relative to repo root
-  return joinPath(REPO_ROOT, path);
-}
+1. **Template Lookup**: Retrieve template by name from TaskLibrary
+2. **Argument Resolution**: For each argument in the caller's environment:
+   - For string values: Try variable lookup first, fallback to literal value
+   - For AST nodes: Recursively evaluate in caller's environment
+3. **Fresh Environment Creation**: Create new environment with parameter bindings
+   - Parameters explicitly bound to evaluated argument values
+   - No implicit access to caller's variables
+4. **Isolated Execution**: Execute template in this clean environment
 
-// Template processing with merged settings
-function processTemplate(template) {
-  const operatorType = template.type;
-  
-  // Get defaults based on type and subtype
-  let defaults;
-  if (operatorType === 'atomic' && template.subtype) {
-    defaults = DEFAULT_CONTEXT_SETTINGS[operatorType][template.subtype] || 
-               DEFAULT_CONTEXT_SETTINGS[operatorType].default;
-  } else {
-    defaults = DEFAULT_CONTEXT_SETTINGS[operatorType];
-  }
-  
-  // The Evaluator stores the TaskResult's notes field (and optionally content) based on the task's accumulation_format setting.
-  // No additional summary generation is performed - the notes field as generated by the LLM is preserved directly.
-  
-  // Special case: For subtask requests via CONTINUATION, use subtask defaults
-  if (operatorType === 'atomic' && template.source === 'continuation') {
-    defaults = DEFAULT_CONTEXT_SETTINGS.atomic.subtask;
-  }
-  
-  // If context_management is present, merge with defaults
-  if (template.contextManagement) {
-    const mergedSettings = {
-      ...defaults,
-      ...template.contextManagement
-    };
-    
-    // Validate mutual exclusivity constraint
-    if ((mergedSettings.inheritContext === 'full' || mergedSettings.inheritContext === 'subset') 
-        && mergedSettings.freshContext === 'enabled') {
-      throw new Error('Invalid context management configuration: fresh_context="enabled" cannot be combined with inherit_context="full" or inherit_context="subset"');
-    }
-    
-    return mergedSettings;
-  }
-  
-  // Otherwise use defaults
-  return defaults;
-}
+This process maintains clean scope boundaries, preventing unintended variable access.
 
-// Context Constraint Validation
-function validateContextSettings(settings) {
-  // Check for mutual exclusivity violation
-  if ((settings.inheritContext === 'full' || settings.inheritContext === 'subset') 
-      && settings.freshContext === 'enabled') {
-    return {
-      valid: false,
-      error: 'Context constraint violation: fresh_context="enabled" cannot be combined with inherit_context="full" or inherit_context="subset"'
-    };
-  }
-  
-  // Check for empty context warning
-  if (settings.inheritContext === 'none' && !settings.accumulateData && settings.freshContext === 'disabled') {
-    return {
-      valid: true,
-      warning: 'Warning: Task will execute with minimal context (no inheritance, no accumulation, no fresh context)'
-    };
-  }
-  
-  return { valid: true };
-}
+## Subtask Spawning Implementation
 
-async function getContextForTask(task: TaskDefinition, parentContext: ExecutionContext): Promise<ExecutionContext> {
-  // Start with base context according to inherit_context setting
-  let context = getBaseContext(task.context_management?.inherit_context, parentContext);
-  
-  // If file_paths is specified, fetch those files
-  if (task.file_paths && task.file_paths.length > 0) {
-    context = await fetchAndAddFiles(task.file_paths, context);
-  }
-  
-  // If fresh_context is enabled, still do associative matching
-  if (task.context_management?.fresh_context === 'enabled') {
-    const freshContext = await memorySystem.getRelevantContextFor({
-      taskText: task.description,
-      inheritedContext: context.inherit_context === 'none' ? undefined : context
-    });
-    
-    // Combine fresh context with existing context
-    context = combineContexts(context, freshContext);
-  }
-  
-  return context;
+The Task System implements the subtask tool mechanism as defined in [Pattern:ToolInterface:1.0], using the CONTINUATION status internally. From the LLM's perspective, these appear as tools but are implemented using the subtask spawning protocol.
+
+Key responsibilities in this pattern:
+- Handling CONTINUATION requests from subtask tool calls
+- Managing context according to the specified configuration
+- Coordinating script execution when required
+- Passing evaluation results back to the Director
+
+When creating subtasks with explicit file paths:
+```typescript
+// The file_paths field takes precedence over associative matching
+subtask_request = {
+  type: "atomic",
+  description: "Analyze specific modules",
+  inputs: { /* parameters */ },
+  context_management: { inherit_context: "subset" },
+  file_paths: ["/src/main.py", "/src/utils.py"]
 }
 ```
+The system ensures these files are fetched and included in the subtask's context before execution.
+
+## Integration Points
 
-During task execution, the final merged configuration is passed to the Evaluator, which applies the settings accordingly.
+### Memory System Integration
+- Memory System provides metadata management and associative matching
+- Task System delegates file operations to Handler
+- Clear separation between metadata and file content
+- Context retrieval through standard ContextGenerationInput interface
+
+### Evaluator Integration
+- Evaluator handles template substitution and function calls
+- Task System provides templates and execution coordination
+- Evaluator manages execution context and variable resolution
+- Clear separation of concerns between components
+
+### Handler Integration
+- Handler provides LLM interaction and resource tracking
+- Task System delegates LLM calls to Handler
+- Clear responsibility boundaries for resource management
+- Standardized tool interface across components
 
 ## Task Template Matching
 
diff --git a/claude/docs/components/task-system/impl/examples.md b/claude/docs/components/bk_components/task-system/impl/examples.md
similarity index 100%
rename from claude/docs/components/task-system/impl/examples.md
rename to claude/docs/components/bk_components/task-system/impl/examples.md
diff --git a/claude/docs/components/bk_components/task-system/impl/examples/basic-execution.md b/claude/docs/components/bk_components/task-system/impl/examples/basic-execution.md
new file mode 100644
index 0000000..0fec92c
--- /dev/null
+++ b/claude/docs/components/bk_components/task-system/impl/examples/basic-execution.md
@@ -0,0 +1,130 @@
+# Basic Task Execution Examples
+    
+This document contains examples of basic Task System initialization and execution.
+    
+## Task System Initialization
+    
+```typescript
+// Initialize TaskSystem
+const taskSystem = new TaskSystem({
+  maxTurns: 10,
+  maxContextWindowFraction: 0.8,
+  systemPrompt: "Default system prompt"
+});
+
+// Register handlers
+taskSystem.onError((error) => {
+  console.error('Task error:', error);
+});
+
+taskSystem.onWarning((warning) => {
+  console.warn('XML validation warning:', warning.message);
+});
+```
+    
+## Task Execution
+    
+```typescript
+// Execute task
+const result = await taskSystem.executeTask(
+  "analyze data",
+  memorySystem
+);
+
+// Check XML parsing status
+if (!result.outputs.some(output => output.wasXMLParsed)) {
+  console.warn("XML parsing failed, using fallback string output");
+}
+```
+    
+## Task Management
+    
+```typescript
+const taskDef: TaskDefinition = {
+  name: "process_data",
+  type: "atomic",
+  provider: "anthropic",
+  model: "claude-3-sonnet",
+  body: {
+    type: "atomic",
+    content: `<task>
+      <description>Process data using specific format</description>
+      <inputs>
+        <input name="raw_data">
+          <description>Load and validate input data</description>
+          <expected_output>
+            Validated data in standard format:
+            - Field validations complete
+            - Type conversions applied
+            - Missing values handled
+          </expected_output>
+        </input>
+      </inputs>
+      <expected_output>
+        Processed data meeting format requirements:
+        - Correct structure
+        - Valid field types
+        - Complete required fields
+      </expected_output>
+    </task>`
+  },
+  metadata: {
+    isManualXML: true,
+    disableReparsing: true
+  }
+};
+
+// Register the task
+await taskSystem.registerTask(taskDef);
+
+// Validate task
+const validation = taskSystem.validateTask(taskDef);
+
+if (!validation.valid) {
+  console.warn('Task validation warnings:', validation.warnings);
+}
+
+// Find matching tasks
+const matches = await taskSystem.findMatchingTasks(
+  "analyze peak patterns",
+  memorySystem
+);
+
+console.log('Found matching tasks:', 
+  matches.map(m => ({
+    score: m.score,
+    type: m.task.type,
+    name: m.task.name
+  }))
+);
+```
+    
+## Resource Management
+    
+```typescript
+// Configure with resource limits
+const taskSystem = new TaskSystem({
+  maxTurns: 5,
+  maxContextWindowFraction: 0.5,
+  systemPrompt: "Resource-constrained execution"
+});
+
+try {
+  const result = await taskSystem.executeTask(
+    "process large dataset",
+    memorySystem
+  );
+} catch (error) {
+  if (error.type === 'RESOURCE_EXHAUSTION') {
+    console.log('Resource limit exceeded:', error.resource);
+    console.log('Usage metrics:', error.metrics);
+  }
+}
+```
+    
+## Related Documentation
+    
+For more details, see:
+- [Task System Interfaces](../../api/interfaces.md)
+- [Resource Management Implementation](../resource-management.md)
+- [Task Type Definitions](../../spec/types.md)
diff --git a/claude/docs/components/bk_components/task-system/impl/examples/context-management.md b/claude/docs/components/bk_components/task-system/impl/examples/context-management.md
new file mode 100644
index 0000000..80a9d85
--- /dev/null
+++ b/claude/docs/components/bk_components/task-system/impl/examples/context-management.md
@@ -0,0 +1,201 @@
+# Context Management Examples
+    
+This document contains examples of context management in the Task System.
+    
+## Context Management Configuration
+    
+### Standard Context Management Structure
+    
+```xml
+<task>
+    <description>Task description</description>
+    <context_management>
+        <inherit_context>none|full|subset</inherit_context>
+        <accumulate_data>true|false</accumulate_data>
+        <accumulation_format>notes_only|full_output</accumulation_format>
+        <fresh_context>enabled|disabled</fresh_context>
+    </context_management>
+    <inputs>
+        <input name="input_name" from="source_var"/>
+    </inputs>
+</task>
+```
+    
+### Context Management Patterns
+    
+#### Default Context Management
+    
+```xml
+<!-- Example: Sequential Task with Default Context Management -->
+<task type="sequential">
+    <description>Process and analyze data</description>
+    <!-- No context_management block - using defaults:
+         inherit_context: full
+         accumulate_data: true
+         accumulation_format: notes_only
+         fresh_context: enabled -->
+    <steps>
+        <task>
+            <description>Load dataset</description>
+            <inputs>
+                <input name="data_file" from="csv_file_path"/>
+            </inputs>
+        </task>
+        <task>
+            <description>Filter invalid rows</description>
+        </task>
+    </steps>
+</task>
+```
+    
+#### Custom Context Management
+    
+```xml
+<!-- Example: Sequential Task with Custom Context Management -->
+<task type="sequential">
+    <description>Process and analyze data</description>
+    <context_management>
+        <inherit_context>none</inherit_context>
+        <accumulate_data>true</accumulate_data>
+        <accumulation_format>full_output</accumulation_format>
+        <fresh_context>enabled</fresh_context>
+    </context_management>
+    <steps>
+        <task>
+            <description>Load dataset</description>
+            <inputs>
+                <input name="data_file" from="csv_file_path"/>
+            </inputs>
+        </task>
+        <task>
+            <description>Filter invalid rows</description>
+        </task>
+    </steps>
+</task>
+```
+    
+## Context Inheritance Patterns
+    
+### Pattern 1: Clear All Context (Fresh Start)
+    
+```xml
+<task type="atomic">
+    <description>Start with completely fresh context</description>
+    <context_management>
+        <inherit_context>none</inherit_context>
+        <accumulate_data>false</accumulate_data>
+        <fresh_context>enabled</fresh_context>
+    </context_management>
+</task>
+```
+    
+### Pattern 2: Rebuild Context While Preserving History
+    
+```xml
+<task type="sequential">
+    <description>Rebuild context while keeping step history</description>
+    <context_management>
+        <inherit_context>none</inherit_context>
+        <accumulate_data>true</accumulate_data>
+        <accumulation_format>notes_only</accumulation_format>
+        <fresh_context>enabled</fresh_context>
+    </context_management>
+    <steps>
+        <task>
+            <description>First step</description>
+        </task>
+        <task>
+            <description>Second step with fresh context but notes from first step</description>
+        </task>
+    </steps>
+</task>
+```
+    
+### Pattern 3: Complete Context Preservation
+    
+```xml
+<task type="sequential">
+    <description>Preserve all context</description>
+    <context_management>
+        <inherit_context>full</inherit_context>
+        <accumulate_data>true</accumulate_data>
+        <accumulation_format>full_output</accumulation_format>
+        <fresh_context>disabled</fresh_context>
+    </context_management>
+    <steps>
+        <task>
+            <description>First step</description>
+        </task>
+        <task>
+            <description>Second step with all context preserved</description>
+        </task>
+    </steps>
+</task>
+```
+    
+## File Path Examples
+    
+### Atomic Task with File Paths
+    
+```xml
+<!-- Example: Atomic Task with File Paths -->
+<task type="atomic">
+    <description>Analyze the main source files</description>
+    <context_management>
+        <inherit_context>none</inherit_context>
+        <fresh_context>disabled</fresh_context>
+    </context_management>
+    <file_paths>
+        <path>./src/main.py</path>
+        <path>./src/utils.py</path>
+    </file_paths>
+</task>
+```
+    
+### Combining File Paths with Context Management
+    
+```xml
+<!-- Example: Combining File Paths with fresh_context -->
+<task type="atomic">
+    <description>Analyze code with base context and specific files</description>
+    <context_management>
+        <inherit_context>none</inherit_context>
+        <fresh_context>enabled</fresh_context>
+    </context_management>
+    <file_paths>
+        <path>./src/main.py</path>
+        <path>./src/utils.py</path>
+    </file_paths>
+</task>
+```
+    
+## TypeScript Usage Example
+    
+```typescript
+// Execute atomic task with specific file paths
+const result = await taskSystem.executeTask(
+  "<task type='atomic'><description>Analyze source files</description><file_paths><path>./src/main.py</path><path>./src/utils.py</path></file_paths></task>",
+  memorySystem
+);
+
+// Create subtask request with file paths
+return {
+  status: "CONTINUATION",
+  notes: {
+    subtask_request: {
+      type: "atomic",
+      description: "Analyze specific modules",
+      inputs: { level: "detailed" },
+      context_management: { inherit_context: "subset" },
+      file_paths: ["./src/main.py", "./src/utils.py"]
+    }
+  }
+};
+```
+    
+## Related Documentation
+    
+For more details, see:
+- [Context Frame Pattern](../../../../system/architecture/patterns/context-frames.md)
+- [ADR 14: Operator Context Configuration](../../../../system/architecture/decisions/completed/014-operator-ctx-config.md)
+- [Context Management Implementation](../design.md#context-management-implementation)
diff --git a/claude/docs/components/bk_components/task-system/impl/examples/error-handling.md b/claude/docs/components/bk_components/task-system/impl/examples/error-handling.md
new file mode 100644
index 0000000..2bc2f68
--- /dev/null
+++ b/claude/docs/components/bk_components/task-system/impl/examples/error-handling.md
@@ -0,0 +1,172 @@
+# Error Handling Examples
+    
+This document contains examples of error handling in the Task System.
+    
+## Resource Exhaustion Handling
+    
+```typescript
+try {
+  const result = await taskSystem.executeTask(
+    "process large dataset",
+    memorySystem
+  );
+} catch (error) {
+  if (error.type === 'RESOURCE_EXHAUSTION') {
+    console.log('Resource limit exceeded:', error.resource);
+    console.log('Usage metrics:', error.metrics);
+    
+    // Take appropriate recovery action based on resource type
+    if (error.resource === 'turns') {
+      console.log('Turn limit exceeded - consider task decomposition');
+    } else if (error.resource === 'context') {
+      console.log('Context window exceeded - consider reducing context size');
+    }
+  }
+}
+```
+    
+## Task Failure Handling
+    
+```typescript
+// Example of error handling with simplified structure
+try {
+  const result = await taskSystem.executeTask(taskDefinition, memorySystem);
+  // Success case: content is complete
+  console.log("Task completed successfully:", result.content);
+} catch (error) {
+  if (error.type === 'RESOURCE_EXHAUSTION') {
+    console.log(`Resource limit exceeded: ${error.resource}`);
+  } else if (error.type === 'TASK_FAILURE') {
+    // Access partial content directly from content field
+    console.log(`Partial output before failure: ${error.content}`);
+    console.log(`Execution stage: ${error.notes.executionStage || "unknown"}`);
+    console.log(`Completion: ${error.notes.completionPercentage || 0}%`);
+  }
+}
+```
+    
+## Subtask Failure Handling
+    
+```typescript
+try {
+  const result = await taskSystem.executeTask("analyze complex document");
+  console.log("Analysis complete:", result.content);
+} catch (error) {
+  // Standard error types without complex partial results
+  if (error.type === 'RESOURCE_EXHAUSTION') {
+    console.log(`Resource limit exceeded: ${error.resource}`);
+  } else if (error.type === 'TASK_FAILURE') {
+    console.log(`Task failed: ${error.message}`);
+    
+    // If this was a subtask failure, the error contains the original request
+    if (error.reason === 'subtask_failure') {
+      console.log(`Failed subtask: ${error.details.subtaskRequest.description}`);
+      
+      // Access the original subtask request for potential retry
+      const modifiedRequest = {
+        ...error.details.subtaskRequest,
+        description: `Retry: ${error.details.subtaskRequest.description} with simplified approach`
+      };
+      
+      // Attempt recovery with modified request
+      try {
+        const recoveryResult = await taskSystem.executeTask(modifiedRequest);
+        console.log("Recovery succeeded:", recoveryResult.content);
+      } catch (recoveryError) {
+        console.log("Recovery failed:", recoveryError.message);
+      }
+    }
+  }
+}
+```
+    
+## Sequential Task Failure
+    
+```typescript
+{
+  type: 'TASK_FAILURE',
+  reason: 'subtask_failure',
+  message: 'Sequential task "Process Dataset" failed at step 3',
+  details: {
+    failedStep: 2,
+    totalSteps: 5,
+    partialResults: [
+      { 
+        stepIndex: 0, 
+        content: "Data loaded successfully: 1000 records",
+        notes: { 
+          recordCount: 1000, 
+          status: "completed"
+        }
+      },
+      { 
+        stepIndex: 1, 
+        content: "Data transformed to required format",
+        notes: { 
+          transformType: "normalization", 
+          status: "completed"
+        }
+      }
+    ]
+  }
+}
+```
+    
+## Reduce Task Failure
+    
+```typescript
+{
+  type: 'TASK_FAILURE',
+  reason: 'subtask_failure',
+  message: 'Reduce task "Aggregate metrics" failed processing input 2',
+  details: {
+    failedInputIndex: 2,
+    totalInputs: 5,
+    processedInputs: [0, 1],
+    currentAccumulator: { totalCount: 1500, averageValue: 42.3 },
+    partialResults: [
+      { 
+        inputIndex: 0, 
+        content: "Processed metrics for server 1",
+        notes: { 
+          status: "completed",
+          serverName: "server-01",
+          metricsCount: 250
+        }
+      },
+      { 
+        inputIndex: 1, 
+        content: "Processed metrics for server 2",
+        notes: { 
+          status: "completed",
+          serverName: "server-02",
+          metricsCount: 180
+        }
+      }
+    ]
+  }
+}
+```
+    
+## Output Format Failure
+    
+```typescript
+// Example error structure for output_format_failure
+{
+  type: 'TASK_FAILURE',
+  reason: 'output_format_failure',
+  message: 'Expected output of type "array" but got "object"',
+  details: {
+    expectedType: "array",
+    actualType: "object",
+    content: "..." // The original output in content field
+  }
+}
+```
+    
+## Related Documentation
+    
+For more details, see:
+- [Error Handling Pattern](../../../../system/architecture/patterns/errors.md)
+- [ADR 8: Error Taxonomy](../../../../system/architecture/decisions/8-errors.md)
+- [ADR 9: Partial Results Policy](../../../../system/architecture/decisions/completed/009-partial-results.md)
diff --git a/claude/docs/components/bk_components/task-system/impl/examples/function-templates.md b/claude/docs/components/bk_components/task-system/impl/examples/function-templates.md
new file mode 100644
index 0000000..b8c94a0
--- /dev/null
+++ b/claude/docs/components/bk_components/task-system/impl/examples/function-templates.md
@@ -0,0 +1,140 @@
+# Function Template Examples
+    
+This document contains examples of function-based templates in the Task System.
+    
+## Basic Function-Style Task Definition
+    
+```xml
+<template name="validate_input" params="data,rules">
+  <task>
+    <description>Validate {{data}} against {{rules}}</description>
+    <context_management>
+      <inherit_context>none</inherit_context>
+      <fresh_context>enabled</fresh_context>
+    </context_management>
+  </task>
+</template>
+```
+    
+## Function Call with Variable Arguments
+    
+```xml
+<call template="validate_input">
+  <arg>user_input</arg>        <!-- Resolved as variable if possible -->
+  <arg>validation_schema</arg>  <!-- Or used as literal if no variable matches -->
+</call>
+```
+    
+## Function-Style Task with Return Type
+    
+```xml
+<template name="extract_metrics" params="log_data" returns="object">
+  <task>
+    <description>Extract performance metrics from {{log_data}}</description>
+    <output_format type="json" schema="object" />
+  </task>
+</template>
+```
+    
+## Complex Function Composition
+    
+```xml
+<task type="sequential">
+  <steps>
+    <task>
+      <description>Load input data</description>
+    </task>
+    <call template="validate_input">
+      <arg>loaded_data</arg>
+      <arg>{"required": ["name", "email"], "format": {"email": "email"}}</arg>
+    </call>
+    <call template="process_validated_data">
+      <arg>validation_result</arg>
+      <arg>processing_options</arg>
+    </call>
+  </steps>
+</task>
+```
+    
+## Task with JSON Output Format
+    
+```xml
+<task type="atomic">
+  <description>List files in directory</description>
+  <output_format type="json" schema="string[]" />
+</task>
+```
+    
+## Template with Return Type
+    
+```xml
+<template name="get_file_info" params="filepath" returns="object">
+  <task>
+    <description>Get metadata for {{filepath}}</description>
+    <output_format type="json" schema="object" />
+  </task>
+</template>
+```
+    
+## Function Call with JSON Result
+    
+```xml
+<task type="sequential">
+  <steps>
+    <task>
+      <description>Get directory listing</description>
+    </task>
+    <call template="get_file_info">
+      <arg>result[0]</arg>
+    </call>
+  </steps>
+</task>
+```
+    
+## TypeScript Implementation
+    
+```typescript
+// 1. Register function-style task with explicit parameters
+await taskSystem.registerTask({
+  name: "analyze_data",
+  type: "atomic",
+  parameters: ["dataset", "config"],  // Explicitly declared parameters
+  body: {
+    type: "atomic",
+    content: "Analyze {{dataset}} using {{config}}",
+  },
+  returns: "object",
+  provider: "anthropic"
+});
+
+// 2. Setup caller environment with variables
+const callerEnv = new Environment({
+  data_file: "sensor_readings.csv",
+  analysis_options: {method: "statistical", outliers: "remove"}
+});
+
+// 3. Execute call with arguments evaluated in caller's environment
+const result = await taskSystem.executeCall({
+  taskName: "analyze_data",
+  arguments: [
+    "data_file",         // Resolved to "sensor_readings.csv" from callerEnv
+    "analysis_options"   // Resolved to the object from callerEnv
+  ]
+}, callerEnv);
+
+// 4. Example with mixed variable/literal arguments
+const mixedResult = await taskSystem.executeCall({
+  taskName: "analyze_data",
+  arguments: [
+    "data_file",                     // Variable lookup
+    {method: "custom", limit: 100}   // Direct literal (no lookup)
+  ]
+}, callerEnv);
+```
+    
+## Related Documentation
+    
+For more details, see:
+- [ADR 12: Function-Based Templates](../../../../system/architecture/decisions/completed/012-function-based-templates.md)
+- [ADR 13: JSON Output](../../../../system/architecture/decisions/completed/013-json-output.md)
+- [Function Template Implementation](../design.md#function-call-processing)
diff --git a/claude/docs/components/bk_components/task-system/impl/examples/subtask-spawning.md b/claude/docs/components/bk_components/task-system/impl/examples/subtask-spawning.md
new file mode 100644
index 0000000..2e76c54
--- /dev/null
+++ b/claude/docs/components/bk_components/task-system/impl/examples/subtask-spawning.md
@@ -0,0 +1,191 @@
+# Subtask Spawning Examples
+    
+This document contains examples of subtask spawning in the Task System.
+    
+## Basic Subtask Request Example
+    
+```typescript
+// Parent task implementation
+async function processComplexTask(input: string): Promise<TaskResult> {
+  // Determine if we need to spawn a subtask
+  if (isComplexInput(input)) {
+    // Return a continuation with subtask request
+    return {
+      content: "Need to process complex input with a specialized subtask",
+      status: "CONTINUATION",
+      notes: {
+        subtask_request: {
+          type: "atomic",
+          description: "Process complex data structure",
+          inputs: {
+            data: input,
+            format: "json",
+            validation_rules: { required: ["id", "name"] }
+          },
+          template_hints: ["data_processor", "validator"],
+          context_management: {
+            inherit_context: "subset",
+            fresh_context: "enabled"
+          }
+        }
+      }
+    };
+  }
+  
+  // Process simple input directly
+  return {
+    content: `Processed: ${input}`,
+    status: "COMPLETE",
+    notes: { dataUsage: "Simple processing completed" }
+  };
+}
+```
+    
+## Example with Explicit File Paths
+    
+```typescript
+// Subtask with explicit files
+return {
+  status: "CONTINUATION",
+  notes: {
+    subtask_request: {
+      type: "atomic",
+      description: "Analyze code modules",
+      inputs: { analysis_depth: "detailed" },
+      context_management: { inherit_context: "subset" },
+      file_paths: ["/src/main.py", "/src/utils.py"]
+    }
+  }
+};
+```
+    
+## Subtask Tool Implementation
+    
+```typescript
+// Example of what happens internally in taskSystem.executeTask
+async function internalTaskSystemFlow(task, context) {
+  // Get or create a Handler
+  const handler = this.getHandlerForTask(task);
+  
+  // Execute the initial prompt
+  const result = await handler.executePrompt(task.taskPrompt);
+  
+  // Check for continuation
+  if (result.status === "CONTINUATION" && result.notes?.subtask_request) {
+    // Execute the subtask
+    const subtaskResult = await this.executeSubtask(result.notes.subtask_request);
+    
+    // Add subtask result as a tool response to parent's session
+    handler.addToolResponse(
+      this.getToolNameFromRequest(result.notes.subtask_request),
+      subtaskResult.content
+    );
+    
+    // Continue parent execution
+    return handler.executePrompt("Continue based on the tool results.");
+  }
+  
+  return result;
+}
+```
+    
+## Tool vs. Subtask Implementation
+    
+```typescript
+// Example of Handler registering both tool types
+handler.registerDirectTool("readFile", async (path) => {
+  return await fs.readFile(path, 'utf8');
+});
+
+handler.registerSubtaskTool("analyzeData", ["data_analysis", "statistical"]);
+
+// LLM usage looks similar for both
+const fileContent = tools.readFile("data.csv");
+const analysis = tools.analyzeData({ 
+  data: fileContent,
+  method: "statistical"
+});
+
+// But implementations differ:
+// Direct tool implementation (in Handler)
+async function executeReadFile(path) {
+  return await fs.readFile(path, 'utf8');
+}
+
+// Subtask tool implementation (via CONTINUATION)
+async function executeAnalyzeData(params) {
+  return {
+    status: "CONTINUATION",
+    notes: {
+      subtask_request: {
+        type: "atomic",
+        description: `Analyze data using ${params.method}`,
+        inputs: params,
+        template_hints: ["data_analysis"]
+      }
+    }
+  };
+}
+```
+    
+## Context Integration Example
+    
+```typescript
+// TypeScript implementation showing context flow
+async function executeWithContextIntegration() {
+  // Execute parent task
+  const parentResult = await taskSystem.executeTask(
+    "<task><description>Analyze code repository structure</description></task>",
+    memorySystem
+  );
+  
+  // Check for continuation with subtask request
+  if (parentResult.status === "CONTINUATION" && 
+      parentResult.notes.subtask_request) {
+    
+    const subtaskRequest = parentResult.notes.subtask_request;
+    
+    // Context management settings from request (or defaults)
+    const contextSettings = subtaskRequest.context_management || {
+      inherit_context: "subset",
+      fresh_context: "enabled"
+    };
+    
+    // Get appropriate context based on settings
+    let subtaskContext;
+    if (contextSettings.inherit_context === "full") {
+      subtaskContext = parentContext;
+    } else if (contextSettings.inherit_context === "subset") {
+      // Get relevant subset via associative matching
+      subtaskContext = await memorySystem.getRelevantContextFor({
+        taskText: subtaskRequest.description,
+        inheritedContext: parentContext
+      });
+    } else {
+      // No inherited context
+      subtaskContext = null;
+    }
+    
+    // Execute subtask with appropriate context
+    const subtaskResult = await taskSystem.executeSubtask(
+      subtaskRequest,
+      subtaskContext
+    );
+    
+    // Resume parent task with subtask result
+    const finalResult = await taskSystem.resumeTask(
+      parentResult,
+      { subtask_result: subtaskResult }
+    );
+    
+    console.log("Final analysis:", finalResult.content);
+  }
+}
+```
+    
+## Related Documentation
+    
+For more details, see:
+- [ADR 11: Subtask Spawning Mechanism](../../../../system/architecture/decisions/completed/011-subtask-spawning.md)
+- [Pattern:ToolInterface:1.0](../../../../system/architecture/patterns/tool-interface.md)
+- [Subtask Spawning Implementation](../design.md#subtask-spawning-implementation)
diff --git a/claude/docs/components/bk_components/task-system/impl/index.md b/claude/docs/components/bk_components/task-system/impl/index.md
new file mode 100644
index 0000000..ec063d0
--- /dev/null
+++ b/claude/docs/components/bk_components/task-system/impl/index.md
@@ -0,0 +1,27 @@
+# Task System Implementation Documentation
+    
+This document provides an index of implementation details for the Task System component.
+    
+## Implementation Files
+    
+- [Design Documentation](./design.md) - Core design details for the Task System
+- [Resource Management](./resource-management.md) - Resource tracking implementation
+- [XML Processing](./xml-processing.md) - XML schema processing details
+- [Examples](./examples/) - Implementation examples by category
+    
+## Documentation Organization
+    
+Implementation examples have been organized by category to improve navigation and clarity. Each example file focuses on a specific aspect of the Task System implementation:
+    
+- [Basic Execution](./examples/basic-execution.md) - Task System initialization and execution
+- [Context Management](./examples/context-management.md) - Context configuration and usage
+- [Error Handling](./examples/error-handling.md) - Error detection and response
+- [Function Templates](./examples/function-templates.md) - Function-based template usage
+- [Subtask Spawning](./examples/subtask-spawning.md) - Dynamic subtask creation and execution
+    
+## Related Specifications
+    
+- [Task System Requirements](../spec/requirements.md)
+- [Task System Behaviors](../spec/behaviors.md)
+- [Task System Types](../spec/types.md)
+- [Task System Interfaces](../spec/interfaces.md)
diff --git a/claude/docs/components/task-system/impl/resource-management.md b/claude/docs/components/bk_components/task-system/impl/resource-management.md
similarity index 85%
rename from claude/docs/components/task-system/impl/resource-management.md
rename to claude/docs/components/bk_components/task-system/impl/resource-management.md
index 4cc50d9..947f145 100644
--- a/claude/docs/components/task-system/impl/resource-management.md
+++ b/claude/docs/components/bk_components/task-system/impl/resource-management.md
@@ -1,30 +1,34 @@
 # Resource Management Implementation
 
-> **Further Reading:** For an architectural overview of resource management principles, see [system/architecture/patterns/resource-management.md](../system/architecture/patterns/resource-management.md).
+> **Further Reading:** For an architectural overview of resource management principles, see [Pattern:ResourceManagement:1.0](../../../system/architecture/patterns/resource-management.md).
 
-## Core Principles
+## Overview
+
+The Resource Management implementation follows these core principles:
 - No resource usage prediction
 - No task decomposition optimization
 - Handler-based resource tracking
 - Clear resource ownership boundaries
 
-## Turn Counter Management
+## Resource Tracking Implementation
+
+### Turn Counter Management
 
-### Implementation Details
+#### Implementation Details
 - Per-Handler turn tracking
 - Atomic increment operations
 - Strict limit enforcement
 - No cross-Handler pooling
 
-### Turn Management Rules
+#### Turn Management Rules
 - Turn tracking owned by Handler instance
 - Turn limit passed during Handler initialization
 - Interactive sessions count against turn limits
 
-### Usage Tracking
+#### Usage Tracking
 ```typescript
 // Using canonical ResourceMetrics definition from spec/types.md
-// See [Type:ResourceMetrics:1.0]
+// See [Type:TaskSystem:ResourceMetrics:1.0]
 
 class TurnCounter {
   private metrics: ResourceMetrics['turns'];
@@ -39,24 +43,18 @@ class TurnCounter {
 }
 ```
 
-### Configuration
-- Default turn limits from config
-- Per-task limit overrides
-- Warning at 80% threshold
-- Error at limit reached
-
-## Context Window Management
+### Context Window Management
 
-### Size Tracking
+#### Size Tracking
 - Token-based calculation
 - Window size monitoring
 - Fraction-based limits
 - No content optimization
 
-### Implementation
+#### Implementation
 ```typescript
 // Using canonical ResourceMetrics definition from spec/types.md
-// See [Type:ResourceMetrics:1.0]
+// See [Type:TaskSystem:ResourceMetrics:1.0]
 
 class ContextManager {
   private metrics: ResourceMetrics['context'];
@@ -72,7 +70,7 @@ class ContextManager {
 }
 ```
 
-### Monitoring
+#### Monitoring
 - Continuous token tracking
 - Peak usage recording
 - Threshold warnings
@@ -92,14 +90,11 @@ class ContextManager {
 - Memory release
 - State invalidation
 
-## Integration Points
+## Integration with Handler
 
-### Handler Integration
-- Resource initialization
-- Usage monitoring
-- Limit enforcement
-- Cleanup coordination
+### Session Implementation
 
+```typescript
 /**
  * Implementation of session-based resource management
  */
@@ -168,9 +163,6 @@ class HandlerSession {
     };
   }
   
-  // resolveTemplatePlaceholders method has been removed
-  // Template substitution is now an Evaluator responsibility
-  
   getResourceMetrics(): ResourceMetrics {
     return {
       turns: this.turnCounter.getMetrics(),
@@ -199,6 +191,9 @@ class HandlerSession {
     return []; // Placeholder - actual implementation would return registered tools
   }
 }
+```
+
+## Integration Points
 
 ### Memory System
 - Read-only metadata access
@@ -212,3 +207,9 @@ class HandlerSession {
 - Clean termination
 - Metric reporting
 - State cleanup
+
+## Related Documentation
+
+For more examples, see:
+- [Basic Execution Examples](./examples/basic-execution.md#resource-management)
+- [Error Handling Examples](./examples/error-handling.md#resource-exhaustion-handling)
diff --git a/claude/docs/components/task-system/impl/xml-processing.md b/claude/docs/components/bk_components/task-system/impl/xml-processing.md
similarity index 86%
rename from claude/docs/components/task-system/impl/xml-processing.md
rename to claude/docs/components/bk_components/task-system/impl/xml-processing.md
index 99eff17..3dae8f7 100644
--- a/claude/docs/components/task-system/impl/xml-processing.md
+++ b/claude/docs/components/bk_components/task-system/impl/xml-processing.md
@@ -1,6 +1,14 @@
 # XML Processing Implementation
 
-> **Overview and References:** This document focuses on the Task System's XML processing implementation. For the complete XML schema definition and template guidelines, please refer to [system/contracts/protocols.md](../system/contracts/protocols.md).
+> **Overview and References:** This document focuses on the Task System's XML processing implementation. For the complete XML schema definition and template guidelines, please refer to [Contract:Tasks:TemplateSchema:1.0](../../../system/contracts/protocols.md).
+
+## Overview
+
+The XML Processing implementation handles:
+- Validation of XML against the schema
+- Template processing and registration
+- Output parsing and validation
+- Error handling for invalid XML
 
 ## Schema Validation
 
@@ -102,7 +110,7 @@
   * Includes expected vs actual type information
   * Preserves original output in error details
 - Template return type validation:
-  * Function templates can specify return types
+  * Function templates can specify return types using the `returns` attribute
   * Return types are validated against actual output
   * Type mismatches generate validation errors
 
@@ -159,3 +167,10 @@ interface XMLError {
 - Handle parsing failures
 - Surface warnings appropriately
 - Maintain execution context
+
+## Related Documentation
+
+For more examples, see:
+- [Function Template Examples](./examples/function-templates.md)
+- [XML Schema Definition](../../../system/contracts/protocols.md#xml-schema-definition)
+- [ADR 13: JSON Output](../../../system/architecture/decisions/completed/013-json-output.md)
diff --git a/claude/docs/components/bk_components/task-system/spec/behaviors.md b/claude/docs/components/bk_components/task-system/spec/behaviors.md
new file mode 100644
index 0000000..5e9b0f9
--- /dev/null
+++ b/claude/docs/components/bk_components/task-system/spec/behaviors.md
@@ -0,0 +1,141 @@
+# Task System Behaviors
+
+This document describes the runtime behaviors of the Task System.
+
+## Overview
+
+The Task System is responsible for managing LLM task execution, including:
+ - Template matching and management,
+ - Lifecycle handling for Handlers,
+ - XML processing with graceful degradation, and
+ - Error detection and recovery.
+
+## Core Behaviors
+
+### Template Management
+- Task templates are stored and validated against the XML schema defined in [Contract:Tasks:TemplateSchema:1.0].
+- The system matches both natural language inputs and AST nodes to candidate templates (up to 5 candidates), using numeric scoring.
+- Templates can define any task type, but only atomic task templates participate in the template matching process.
+- Each template is validated against the XML schema with warnings for non-critical issues.
+
+### Template Variable Substitution
+- The Evaluator is solely responsible for all template variable substitution.
+- This includes resolving all {{variable_name}} placeholders before passing tasks to Handlers.
+- Different resolution rules apply for function templates vs. standard templates.
+- Variable resolution errors are detected early and handled at the Evaluator level.
+
+### Handler Lifecycle
+- A new Handler is created for each task execution with an immutable configuration.
+- The Handler enforces resource limits (turn counts, context window limits) as described in [Pattern:ResourceManagement:1.0].
+- Handlers receive fully resolved content with no remaining template variables.
+- Each Handler maintains its own session with isolated resource tracking.
+
+### XML Processing
+- Basic structural validation is performed, with warnings generated for non‑critical issues.
+- In cases of partial XML parsing failure, the original content is preserved and error details are included in the task notes.
+- The system supports manual XML tasks with the `isManualXML` flag.
+- Output format validation is performed when the `output_format` element is present.
+
+## Task Execution
+
+### Standard Task Execution
+- Process tasks using appropriate templates
+- Return both output and notes sections in TaskResult structure
+- Surface errors for task failure or resource exhaustion
+- Support specialized execution paths for reparsing and memory tasks
+- Implement lenient XML output parsing with fallback to single string
+- Generate warnings for malformed XML without blocking execution
+- Include 'data usage' section in task notes as specified by system prompt
+
+### Output Format Handling
+- Format declaration via `<output_format>` element with required `type` attribute
+- Supported format types:
+  * "json" - Structured JSON data
+  * "text" - Plain text (default)
+- Optional `schema` attribute for type validation:
+  * "object" - JSON object
+  * "array" or "[]" - JSON array
+  * "string[]" - Array of strings
+  * "number" - Validates as numeric value
+  * "boolean" - Validates as boolean value
+- Automatic JSON detection:
+  * Attempts to parse content as JSON when type="json"
+  * Adds parsed content to TaskResult as parsedContent property
+  * Falls back to original string content if parsing fails
+- Type validation process:
+  * Validates parsed content against schema attribute
+  * Generates error if type mismatch occurs
+  * Preserves original content in error details
+
+## Error Handling
+
+### Error Detection
+- Resource exhaustion detection (turns, context, output)
+- XML parsing and validation errors
+- Output format validation errors
+- Task execution failures
+- Progress monitoring
+
+### Error Response
+- Standard error type system with TaskError interface
+- Detailed error information with reason codes
+- Partial results preservation according to task type
+- Clear error messages and locations
+- Resource usage metrics in error responses
+
+### Recovery Delegation
+- No automatic retry attempts
+- Delegates recovery to Evaluator
+- Provides complete error context
+- Includes notes for recovery guidance
+
+## Context Management
+
+### Context Management Behaviors
+- Hybrid configuration approach with operator-specific defaults
+- Three-dimensional model with inherit_context, accumulate_data, and fresh_context
+- Explicit file selection via file_paths element
+- Operator-specific default settings:
+  * atomic: inherit_context="full", fresh_context="disabled"
+  * sequential: inherit_context="full", accumulate_data="true", fresh_context="disabled"
+  * reduce: inherit_context="none", accumulate_data="true", fresh_context="enabled"
+  * script: inherit_context="full", accumulate_data="false", fresh_context="disabled"
+  * director_evaluator_loop: inherit_context="none", accumulate_data="true", fresh_context="enabled"
+- Subtask defaults: inherit_context="subset", fresh_context="enabled"
+
+### File Operations
+- Memory System: Manages ONLY metadata (file paths and descriptive strings)
+- Handler: Performs ALL file I/O operations (reading, writing, deletion)
+- For Anthropic models: Handler configures computer use tools
+- All file content access is always handled by the Handler, never the Memory System
+
+## Integration Behaviors
+
+### Memory System Integration
+- Context accessed via async getRelevantContextFor
+- File metadata accessed via GlobalIndex
+- Existing context preserved during task execution
+- Structure/parsing handled by associative memory tasks
+- Context clearing and regeneration handled through context_management settings
+
+### Tool Interface
+- Unified tool system with consistent patterns
+- Direct tools: Handler-managed operations with fixed APIs
+- Subtask tools: LLM-to-LLM interactions via CONTINUATION
+- Script execution: External command execution with input/output capture
+- User input: Standardized tool for interactive input requests
+
+### Subtask Spawning
+- Request validation with type, description, and inputs
+- Context management with defaults or explicit configuration
+- Depth control to prevent infinite recursion (default: 5 levels)
+- Error handling with standardized error structures
+- Direct parameter passing for clear data flow
+
+## Related Documentation
+
+For implementation details, see:
+- [Design Implementation](../impl/design.md)
+- [Resource Management Implementation](../impl/resource-management.md)
+- [XML Processing Implementation](../impl/xml-processing.md)
+- [Implementation Examples](../impl/examples/)
diff --git a/components/task-system/spec/interfaces.md b/claude/docs/components/bk_components/task-system/spec/interfaces.md
similarity index 100%
rename from components/task-system/spec/interfaces.md
rename to claude/docs/components/bk_components/task-system/spec/interfaces.md
diff --git a/components/task-system/spec/providers.md b/claude/docs/components/bk_components/task-system/spec/providers.md
similarity index 100%
rename from components/task-system/spec/providers.md
rename to claude/docs/components/bk_components/task-system/spec/providers.md
diff --git a/claude/docs/components/task-system/spec/qa.md b/claude/docs/components/bk_components/task-system/spec/qa.md
similarity index 100%
rename from claude/docs/components/task-system/spec/qa.md
rename to claude/docs/components/bk_components/task-system/spec/qa.md
diff --git a/claude/docs/components/task-system/spec/requirements.md b/claude/docs/components/bk_components/task-system/spec/requirements.md
similarity index 100%
rename from claude/docs/components/task-system/spec/requirements.md
rename to claude/docs/components/bk_components/task-system/spec/requirements.md
diff --git a/claude/docs/components/task-system/spec/types.md b/claude/docs/components/bk_components/task-system/spec/types.md
similarity index 100%
rename from claude/docs/components/task-system/spec/types.md
rename to claude/docs/components/bk_components/task-system/spec/types.md
diff --git a/claude/docs/components/compiler/README.md b/claude/docs/components/compiler/README.md
deleted file mode 100644
index a934cfa..0000000
--- a/claude/docs/components/compiler/README.md
+++ /dev/null
@@ -1,64 +0,0 @@
-# Compiler Component
-
-## Overview
-
-The Compiler handles translation and transformation of tasks into executable formats. It parses natural language inputs into structured XML or AST representations that can be processed by the Evaluator.
-
-## Core Architecture
-
-The Compiler provides:
-- Task parsing from natural language to XML/AST
-- XML schema validation
-- Template validation
-- AST transformation capabilities
-
-## Component Interface
-
-```typescript
-interface Compiler {
-    /**
-     * Parse natural language into structured XML or AST
-     */
-    parse(input: string): ASTNode;
-    
-    /**
-     * Validate XML against schema
-     */
-    validateXML(xml: string): ValidationResult;
-    
-    /**
-     * Transform AST nodes
-     */
-    transform(node: ASTNode, transformations: Transformation[]): ASTNode;
-}
-```
-
-For detailed interface definitions, see [components/compiler/api/interfaces.md](./api/interfaces.md).
-
-## Integration Points
-
-- **Task System**: Receives parsed tasks for execution
-- **Evaluator**: Uses AST nodes for execution
-- **XML Schema**: Validates against [Contract:Tasks:TemplateSchema:1.0]
-
-## Usage
-
-```typescript
-const compiler = new Compiler();
-
-// Parse natural language to XML/AST
-const ast = compiler.parse("Analyze the data in file.csv");
-
-// Validate XML
-const validationResult = compiler.validateXML(xmlString);
-if (!validationResult.valid) {
-    console.error("Validation errors:", validationResult.errors);
-}
-
-// Transform AST
-const transformedAST = compiler.transform(ast, [
-    { type: "optimize", options: { level: "basic" } }
-]);
-```
-
-For detailed requirements, see [components/compiler/spec/requirements.md](./spec/requirements.md).
diff --git a/claude/docs/components/evaluator/README.md b/claude/docs/components/evaluator/README.md
deleted file mode 100644
index ef7726e..0000000
--- a/claude/docs/components/evaluator/README.md
+++ /dev/null
@@ -1,54 +0,0 @@
-# Evaluator Component
-
-## Overview
-
-The **Evaluator** is the unified task-execution component of the system. It is responsible for:
-
-1. **Controlling AST processing and execution**  
-2. **Managing failure recovery** via standard task return statuses (`COMPLETE`, `CONTINUATION`, `FAILED`)
-3. **Tracking resource usage** (in coordination with Handlers)
-4. **Handling reparse/decomposition requests** when tasks fail (e.g. due to resource exhaustion or invalid output)
-
-## Core Responsibilities
-
-### AST Execution Controller  
-- Orchestrates the step-by-step or operator-by-operator execution of tasks represented as an AST
-- Calls out to the Handler for LLM-specific interactions and resource tracking
-- Interacts with the Compiler when re-parsing or decomposition is required
-
-### Failure Recovery  
-- Detects or receives error signals when tasks fail or exceed resources  
-- Initiates "reparse" tasks or alternative decomposition approaches if the system's policies allow
-- Surfaces errors back to the Task System or parent contexts
-
-### Resource Usage Coordination  
-- Integrates with Handler's resource tracking
-- Aware of usage or limit errors and decides whether to attempt decomposition or fail outright
-
-### Context and Environment Handling  
-- Ensures proper propagation of parameters and context in multi-step tasks
-- Uses direct parameter passing between tasks rather than environment variables
-- Leverages Memory System 3.0 for associative context retrieval
-- Manages all dimensions of the context management model
-
-### Template Substitution
-- Solely responsible for resolving all template variables before passing tasks to the Handler
-- Handles different resolution rules for function vs. standard templates
-- Ensures all execution happens with fully resolved inputs
-
-## Integration Points
-
-- **Task System**: Receives structured tasks for execution
-- **Handler**: Delegates LLM interactions and resource tracking
-- **Memory System**: Retrieves context via associative matching
-- **Compiler**: Requests reparsing when needed
-
-## References
-
-For detailed implementation design, see [components/evaluator/impl/design.md](./impl/design.md).
-
-For interface definitions, see [components/evaluator/api/interfaces.md](./api/interfaces.md).
-
-For error handling patterns, see [Pattern:Error:1.0](../../system/architecture/patterns/errors.md).
-
-For context management, see [Pattern:ContextFrame:1.0](../../system/architecture/patterns/context-frames.md).
diff --git a/claude/docs/components/memory/README.md b/claude/docs/components/memory/README.md
deleted file mode 100644
index 52c136b..0000000
--- a/claude/docs/components/memory/README.md
+++ /dev/null
@@ -1,63 +0,0 @@
-# Memory System Component [Version 3.0]
-
-## Overview
-
-The Memory System provides context management and associative matching services for task execution. It maintains a global metadata index to support context retrieval while delegating actual file operations to Handler tools. The system focuses purely on metadata management and context retrieval - it does not store file content, perform file operations, track resources, or rank matches.
-
-## Core Architecture
-
-The Memory System follows a read-only context model with a clear separation of responsibilities:
-
-- **Metadata Management**: Maintains file paths and descriptive metadata
-- **Associative Matching**: Provides context retrieval based on task relevance
-- **No File Operations**: Delegates all file I/O to Handler tools
-- **Bulk Index Updates**: Supports global index management through bulk operations
-
-## Core Interface
-
-The Memory System provides a standardized interface as defined in [Interface:Memory:3.0]. This interface supports:
-
-- Global metadata index management through bulk operations
-- Context retrieval through associative matching
-- Clear separation between metadata management and file operations
-
-**IMPORTANT: The Memory System NEVER performs file I/O operations (reading, writing, deletion). All file operations are exclusively handled by Handler tools.**
-
-**NOTE: As of version 3.0, the Memory System follows a read-only context model. The updateContext method has been removed, and all context must be managed through the appropriate context management mechanisms in the Task System.**
-
-For the complete interface specification, method signatures, and type definitions, see [components/memory/api/interfaces.md](./api/interfaces.md).
-
-## Integration Points
-
-The Memory System integrates with other components through clear boundaries:
-
-- **Task System**: Receives context requests and provides associative matching results
-- **Evaluator**: Processes context for task execution
-- **Handler**: Provides file access tools for content retrieval
-- **Error Handling**: Maps failures to standard TASK_FAILURE errors
-
-## Usage
-
-The Memory System is typically used for two main purposes: managing the global metadata index and retrieving context for task execution. Here's a typical usage pattern:
-
-```typescript
-// Initialize and update index
-const memory = new MemorySystem();
-await memory.updateGlobalIndex(new Map([
-    ['data.txt', 'Experimental results from 2024-02'],
-    ['config.json', 'System configuration parameters']
-]));
-
-// Request context for task execution
-const result = await memory.getRelevantContextFor({
-    taskText: "Analyze recent experimental results",
-    inheritedContext: "Previous analysis focused on temperature variance",
-    previousOutputs: "Initial data validation complete"
-});
-```
-
-## Related Documents
-
-For detailed implementation specifications and patterns, refer to:
-- [Pattern:ContextFrame:1.0](../../system/architecture/patterns/context-frames.md)
-- [ADR:Memory:1.0](../../system/architecture/decisions/needs_update/001-memory-system.md)
diff --git a/claude/docs/components/task-system/README.md b/claude/docs/components/task-system/README.md
deleted file mode 100644
index acbd857..0000000
--- a/claude/docs/components/task-system/README.md
+++ /dev/null
@@ -1,186 +0,0 @@
-# Task System Component
-
-## Overview
-
-The Task System orchestrates LLM task execution through structured XML templates and handlers. It proovides template-based task definition, resource tracking, and an XML-based interface with the LLM.
-
-## Core Architecture
-
-The system manages task execution through isolated Handler instances, with one Handler per task to enforce resource limits and manage LLM interactions. 
-
-Task definitions use an XML-based template system that supports both manual and LLM-generated structures. 
-
-## Core Interface
-
-```typescript
-interface TaskSystem {
-    executeTask(
-        task: string,
-        context: MemorySystem,
-        taskType?: TaskType
-    ): Promise<TaskResult>;
-
-    validateTemplate(template: TaskTemplate): boolean;
-    
-    findMatchingTasks(
-        input: string,
-        context: MemorySystem
-    ): Promise<Array<{
-        template: TaskTemplate;
-        score: number;
-        taskType: TaskType;
-    }>>;
-}
-```
-
-## Task Types and Execution
-
-The system supports several task types for different execution patterns. Atomic tasks provide direct LLM execution with resource tracking and output validation. Sequential tasks enable ordered execution with context management between steps. Reduce tasks handle iterative data processing with accumulator management. Script tasks support external command execution with output capture and evaluation flow integration.
-
-For all task types, the Evaluator is responsible for resolving template variables (e.g., `{{variable_name}}` placeholders) before passing fully-resolved content to the Handler for execution. This ensures consistent variable resolution across all task types and execution paths.
-
-All task types (atomic, sequential, reduce, script) can be defined as templates and functions in the TaskLibrary. However, template matching (the process of selecting an appropriate template based on a natural language description) applies only to atomic task templates. Composite tasks can be defined directly, defined as reusable templates, or assembled from matched atomic task templates.
-
-Each task type can specify its context management requirements and explicit file paths through XML configuration:
-
-```xml
-<task>
-    <description>Task description</description>
-    <context_management>
-        <inherit_context>none|full|subset</inherit_context>
-        <accumulate_data>true|false</accumulate_data>
-        <accumulation_format>notes_only|full_output</accumulation_format>
-        <fresh_context>enabled|disabled</fresh_context>
-    </context_management>
-    <file_paths>
-        <path>./src/main.py</path>
-        <path>/absolute/path/file.txt</path>
-    </file_paths>
-    <inputs>
-        <input name="input_name" from="source_var"/>
-    </inputs>
-</task>
-```
-
-### Function Templates
-
-The system supports function-based templates with explicit parameter declarations:
-
-```xml
-<template name="analyze_data" params="dataset,config">
-  <task>
-    <description>Analyze {{dataset}} using {{config}}</description>
-  </task>
-</template>
-```
-
-These templates are called with positional arguments:
-
-```xml
-<call template="analyze_data">
-  <arg>weather_data</arg>
-  <arg>standard_config</arg>
-</call>
-```
-
-Key characteristics:
-
-- Templates can only access explicitly passed parameters
-- Arguments are evaluated in the caller's environment
-- Function calls create a new lexical scope
-- Template registration happens automatically during parsing
-
-## Delegation Mechanisms
-
-The system exposes a unified tool interface with two implementation approaches:
-
-1. **Unified Tool Interface**: What the LLM sees and interacts with
-   - Consistent invocation patterns for all operations
-   - Standardized parameter schemas
-   - Unified error handling
-
-2. **Implementation Mechanisms**: How tools are executed
-   - **Direct Implementation**: Synchronous Handler execution for simple operations
-   - **Subtask Implementation**: Asynchronous execution via CONTINUATION
-
-See [Pattern:ToolInterface:1.0] for complete details on this approach.
-
-## Integration and Dependencies
-
-The Task System integrates with several core components. It uses the Memory System for context access and management, Handler Tools for file and system operations, the Compiler for task parsing and transformation, and the Evaluator for error recovery and task decomposition. These integrations enable comprehensive task execution while maintaining clean component boundaries.
-
-## Usage
-
-Here's how the Task System would be instantiated:
-
-```typescript
-const taskSystem = new TaskSystem({
-    provider: "anthropic",  // Default provider
-    maxTurns: 10,
-    maxContextWindowFraction: 0.8,
-    systemPrompt: "Default system prompt"
-});
-
-// Execute a task
-const result = await taskSystem.executeTask(
-    "analyze data",
-    memorySystem
-);
-
-// Execute with provider override
-const resultWithOverride = await taskSystem.executeTask(
-    "analyze data",
-    memorySystem,
-    { provider: "openai" }  // Override for this task
-);
-
-// Execute task with specific file paths
-const resultWithFiles = await taskSystem.executeTask(
-    "<task type='atomic'><description>Analyze files</description><file_paths><path>./src/main.py</path></file_paths></task>",
-    memorySystem
-);
-
-// Validate a template
-const validation = taskSystem.validateTemplate({
-    taskPrompt: "<task>...</task>",
-    systemPrompt: "System context",
-    model: "claude-3-sonnet",
-    isManualXML: false
-});
-
-// Register a template
-const templateResult = await taskSystem.registerTemplate({
-  name: "process_data",
-  parameters: ["input_file", "options"],
-  body: {
-    type: "atomic",
-    description: "Process {{input_file}} with options {{options}}",
-    // Additional task properties
-  }
-});
-
-// Call a template with arguments
-const callResult = await taskSystem.executeCall({
-  templateName: "process_data",
-  arguments: ["data.csv", {format: "standard"}]
-});
-```
-
-## Error Handling
-
-The system handles several error types during execution, including resource exhaustion (for turns, context, or output), invalid output structure, XML parsing or validation errors, and general task execution failures. Each error type includes relevant context and metrics to aid in recovery and debugging. Errors will be surfaced to the Evaluator, which will use them for control flow.
-
-## Resource Management
-
-Resource management follows strict constraints with fixed context window sizes and limited turn counts. The system ensures clean resource release after task execution and prevents cross-Handler resource sharing. Handler configuration controls these limits:
-
-```typescript
-interface HandlerConfig {
-    maxTurns: number;
-    maxContextWindowFraction: number;
-    defaultModel?: string;
-    systemPrompt: string;
-}
-```
-
-For detailed implementation specifications and patterns, refer to the component-level documentation and system contracts.
diff --git a/claude/docs/components/task-system/spec/behaviors.md b/claude/docs/components/task-system/spec/behaviors.md
deleted file mode 100644
index da034ad..0000000
--- a/claude/docs/components/task-system/spec/behaviors.md
+++ /dev/null
@@ -1,558 +0,0 @@
-# Task System Behaviors
-
-This document describes the runtime behaviors of the Task System.
-
-## Overview
-
-The Task System is responsible for managing LLM task execution, including:
- - Template matching and management,
- - Lifecycle handling for Handlers,
- - XML processing with graceful degradation, and
- - Error detection and recovery.
-
-## Key Behavior Highlights
-
-1. **Template Management:**  
-   - Task templates are stored and validated against the XML schema defined in [Contract:Tasks:TemplateSchema:1.0].  
-   - The system matches both natural language inputs and AST nodes to candidate templates (up to 5 candidates), using numeric scoring.
-
-2. **Template Variable Substitution:**
-   - The Evaluator is solely responsible for all template variable substitution.
-   - This includes resolving all {{variable_name}} placeholders before passing tasks to Handlers.
-   - Different resolution rules apply for function templates vs. standard templates.
-   - Variable resolution errors are detected early and handled at the Evaluator level.
-
-3. **Handler Lifecycle:**  
-   - A new Handler is created for each task execution with an immutable configuration.
-   - The Handler enforces resource limits (turn counts, context window limits) as described in [Pattern:ResourceManagement:1.0].
-   - Handlers receive fully resolved content with no remaining template variables.
-
-4. **XML Processing:**  
-   - Basic structural validation is performed, with warnings generated for non‑critical issues.
-   - In cases of partial XML parsing failure, the original content is preserved and error details are included in the task notes.
-
-5. **Error Handling:**  
-   - Errors such as RESOURCE_EXHAUSTION, TASK_FAILURE, and template resolution failures are surfaced according to the rules defined in [Pattern:Error:1.0].
-   - The Evaluator delegates error recovery (e.g., reparse tasks) and includes partial outputs when available.
-   - Template variable resolution errors are handled specifically with `template_resolution_failure` reason codes.
-
-## See Also
-
- - [Task System Requirements](requirements.md)
- - [Task System Interfaces](interfaces.md)
- - System-level error handling: [Pattern:Error:1.0]
-
-### Interactive Sessions
-- Handler implements a standardized tool-based approach for user input requests
-- The system registers a `requestUserInput` tool during Handler initialization
-- Input Flow:
-  ```
-  LLM -> Calls requestUserInput tool -> Handler detects tool call ->
-  onRequestInput called with prompt -> User input returned ->
-  Handler adds user message to session -> Conversation continues
-  ```
-- Sessions track all conversation turns and message history
-- User messages are added to the session but don't increment turn counters
-- Assistant messages increment turn counters and are tracked for resource limits
-- Context window includes full conversation history managed by HandlerSession
-- HandlerPayload includes all context, messages, and available tools
-
-### XML Processing
-- Basic structural validation only
-- Warning generation for validation issues
-- Lenient output parsing with fallback
-- Graceful handling of partially valid XML
-- Support for manual XML task flag
-
-## Task Execution
-
-### Standard Task Execution
-- Process tasks using appropriate templates
-- Return both output and notes sections in TaskResult structure
-- Surface errors for task failure or resource exhaustion
-- Support specialized execution paths for reparsing and memory tasks
-- Implement lenient XML output parsing with fallback to single string
-- Generate warnings for malformed XML without blocking execution
-- Include 'data usage' section in task notes as specified by system prompt
-
-### Output Format Handling
-- Format declaration via `<output_format>` element with required `type` attribute
-- Supported format types:
-  * "json" - Structured JSON data
-  * "text" - Plain text (default)
-- Optional `schema` attribute for type validation:
-  * "object" - JSON object
-  * "array" or "[]" - JSON array
-  * "string[]" - Array of strings
-  * "number" - Numeric value
-  * "boolean" - Boolean value
-- Automatic JSON detection:
-  * Attempts to parse content as JSON when type="json"
-  * Adds parsed content to TaskResult as parsedContent property
-  * Falls back to original string content if parsing fails
-- Type validation process:
-  * Validates parsed content against schema attribute
-  * Generates error if type mismatch occurs
-  * Preserves original content in error details
-- Template return type validation:
-  * Function templates can specify return types via returns attribute
-  * Return types are validated against actual output
-  * Type mismatches generate validation errors
-
-Example error structure for output_format_failure:
-```typescript
-{
-  type: 'TASK_FAILURE',
-  reason: 'output_format_failure',
-  message: 'Expected output of type "array" but got "object"',
-  details: {
-    expectedType: "array",
-    actualType: "object",
-    content: "..." // The original output is now in content field
-  }
-}
-```
-
-## Output Structure
-
-The Task System uses a simplified output structure:
-
-### Atomic Tasks
-- `content`: Contains all output (complete or partial)
-- `notes`: Contains only metadata (never content)
-- `status` indicates completion:
-  * `COMPLETE`: Content is final
-  * `FAILED`: Content may be partial
-  * `CONTINUATION`: Content is intermediate
-
-### Sequential Tasks
-- Structure preserves step outputs with proper separation:
-  ```typescript
-  partialResults: [
-    {
-      stepIndex: number,
-      content: string,      // Step output
-      metadata: {           // Step metadata
-        status: string,
-        [key: string]: any
-      }
-    }
-  ]
-  ```
-
-### Reduce Tasks
-- Structure preserves processed inputs with proper separation:
-  ```typescript
-  processedResults: [
-    {
-      inputIndex: number,
-      content: string,      // Processing output
-      metadata: {           // Processing metadata
-        status: string,
-        [key: string]: any
-      }
-    }
-  ]
-  ```
-
-This structure maintains clear separation between content and metadata at all levels.
-
-### Task Template Matching
-
-#### Human Input Matching
-- Input: Natural language text + initial environment
-- Process:
-  - Uses matching specialized task from library
-  - Considers provided files in environment
-  - No access to previous executions/history
-- Output: 
-  - Up to 5 highest-scoring templates
-  - Each match includes numeric score and template
-  - Templates ordered by descending score
-
-#### AST Node Matching
-- Input: Single AST node
-- Process:
-  - Uses node-specific matching task
-  - Only considers node-level context
-  - No traversal of parent/child nodes
-- Output:
-  - Up to 5 highest-scoring templates
-  - Each match includes numeric score and template
-  - Templates ordered by descending score
-
-**Additional Matching Details:**
-- **Heuristic Matching:** The matching is performed heuristically using user-defined associative matching tasks. These tasks compute similarity scores based on fixed input/output conventions without a fixed system-wide metric.
-- **Disable Context Flag:** Atomic tasks have an optional "disable context" flag available in their ContextGenerationInput. When enabled, inherited context is omitted from the matching process.
-- **Optional Success Score:** Task execution results may include an optional success score in the `notes` field. This score is used for future adaptive template matching (although adaptive behavior is not part of the MVP).
-
-#### Matching Behavior Summary
-
-```mermaid
-flowchart TD
-    A[User Input: Task Description]
-    B[Create ContextGenerationInput]
-    C{Disable Context Flag?}
-    C -- Yes --> D[Omit inherited context]
-    C -- No --> E[Include inherited context]
-    D & E --> F[Invoke Associative Matching Task]
-    F --> G[Compute Similarity Scores]
-    G --> H[Select Highest-Scoring Atomic Template]
-    H --> I[Return Selected Template]
-```
-
-### Specialized Task Types
-
-#### Reparse Tasks
-- Triggered by:
-  - Resource exhaustion errors
-  - Invalid output errors
-  - Progress failure errors
-- Uses specialized templates from separate directory
-- Returns new task structure or alternative approach
-
-#### Memory Tasks
-- Direct memory system access
-- Uses associative matching templates
-- Returns relevant context selections
-
-## Memory System Integration
-
-### File Operations
-- **Memory System**: Manages ONLY metadata (file paths and descriptive strings)
-- **Handler**: Performs ALL file I/O operations (reading, writing, deletion)
-- For Anthropic models: Handler configures and uses Anthropic's computer use tools
-  * computer_20250124 (or 20241022)
-  * text_editor_20250124 (or 20241022)
-  * bash_20250124 (or 20241022)
-- All file content access is always handled by the Handler, never the Memory System
-
-Note: The Memory System (version 3.0) follows a read-only context model with no updateContext capability.
-
-### Context Management
-- Context accessed via async getRelevantContextFor
-- File metadata accessed via GlobalIndex
-- Existing context preserved during task execution
-- Structure/parsing handled by associative memory tasks
-- Context clearing and regeneration handled through context_management settings
-- Three-dimensional model (inherit_context, accumulate_data, fresh_context) provides complete control
-- No additional flags or mechanisms needed for context operations
-
-#### Context Operation Patterns
-
-1. **Context Clearing**: Achieved by setting `inherit_context="none"` and `fresh_context="enabled"`
-2. **Context Regeneration**: Achieved through `fresh_context="enabled"` with appropriate inheritance settings
-3. **Complete Preservation**: Achieved with `inherit_context="full"`, `accumulate_data="true"`, and `fresh_context="disabled"`
-
-### State Management
-- No complex file metadata tracking
-- Minimal state maintenance between tasks
-- Clear task execution boundaries
-- Simple file modification tracking
-
-## Delegation Mechanisms
-
-## Tool Interface
-The LLM interacts with a unified tool system that presents consistent patterns regardless of implementation mechanism:
-
-```typescript
-// All tools appear similar to the LLM
-tools.readFile("path/to/file");  // Direct implementation
-tools.analyzeData({ data: content });  // Subtask implementation
-```
-
-### Direct Tool Implementation
-- Handled by Handler component
-- Deterministic with fixed APIs
-- No continuation mechanism
-- Used for file operations, APIs, script execution
-- Examples: file access, bash commands, computer tools
-- Direct execution without complex context management
-- Resource tracking handled by Handler
-
-### Subtask Tool Implementation
-- LLM-to-LLM interactions
-- Use CONTINUATION status with SubtaskRequest
-- Full context management via Memory System
-- Support complex reasoning and creative tasks
-- Follow ADR 14 context management model
-- Depth tracking to prevent infinite recursion
-- Template selection via associative matching
-
-See [Pattern:ToolInterface:1.0] for selection criteria and implementation details.
-
-## File Operations
-
-### Clear Responsibility Boundaries
-- **Memory System**: Manages ONLY metadata (file paths and descriptive strings)
-- **Handler**: Performs ALL file I/O operations (reading, writing, deletion)
-
-### Implementation Details
-- Handler configures and uses provider-appropriate tool mechanisms
-- Tool selection is determined by provider capabilities and task requirements
-- Each provider implementation handles the mapping of abstract tool types to provider-specific formats
-- All file content access is always handled by the Handler, never the Memory System
-- The Memory System provides only file paths that may be relevant (via associative matching)
-- Context Management System decides which files to read based on policy
-
-## Subtask Spawning Behavior
-
-The Task System implements a standardized approach to subtask spawning:
-
-### Request Processing
-
-1. **Validation and Preparation**
-   - Validates the SubtaskRequest structure for required fields
-   - Checks nesting depth against maximum allowed (default: 5)
-   - Performs cycle detection to prevent recursive spawning
-   - Prepares context according to context management settings
-   - Prioritizes explicit file_paths when provided with inherit_context="subset"
-
-2. **Template Selection and Execution**
-   - Uses the description and template_hints for associative matching
-   - Selects the highest-scoring template that matches the request
-   - Creates a new execution environment with direct parameter passing
-   - Executes the subtask with appropriate resource tracking
-
-3. **Result Handling**
-   - Adds subtask result as a tool response to parent's Handler session
-   - Parent task continues execution with the tool result in its conversation history
-   - No special resumption methods or partial results tracking needed
-   - Handler session remains preserved throughout the subtask execution
-   - From the LLM's perspective, subtasks appear as normal tool calls and responses
-
-### Explicit File Selection
-
-When creating subtasks, parent tasks can explicitly specify which files to include:
-
-```typescript
-// The file_paths field takes precedence over associative matching
-subtask_request = {
-  type: "atomic",
-  description: "Analyze specific modules",
-  inputs: { /* parameters */ },
-  context_management: { inherit_context: "subset" },
-  file_paths: ["/src/main.py", "/src/utils.py"]
-}
-```
-
-### Context Management Defaults
-
-Subtasks have specific default context management settings:
-
-| Setting | Default Value | Description |
-|---------|---------------|-------------|
-| inherit_context | subset | Inherits only relevant context from parent |
-| accumulate_data | false | Does not accumulate previous step outputs |
-| accumulation_format | notes_only | Stores only summary information |
-| fresh_context | enabled | Generates new context via associative matching |
-
-These defaults can be overridden through explicit configuration in the SubtaskRequest.
-
-### Error Handling
-
-The system uses standard error types (`RESOURCE_EXHAUSTION`, `TASK_FAILURE`) without complex partial results tracking. Errors contain essential information needed for debugging without overengineering the error structure. The parent task receives clear error information and can implement appropriate recovery strategies based on error type and context.
-
-When a subtask fails, a standardized error structure is generated:
-
-```typescript
-{
-  type: 'TASK_FAILURE',
-  reason: 'subtask_failure',
-  message: 'Subtask execution failed',
-  details: {
-    subtaskRequest: {
-      type: 'atomic',
-      description: 'Process data',
-      inputs: { /* original inputs */ }
-    },
-    subtaskError: {
-      type: 'TASK_FAILURE',
-      reason: 'execution_halted',
-      message: 'Failed to process data'
-    },
-    nestingDepth: 2
-  }
-}
-```
-
-This structure provides the essential error context, allowing the parent task to implement recovery strategies if needed.
-
-## Context Management Delegation
-
-The Task System implements a hybrid configuration approach with operator-specific defaults and explicit overrides:
-
-| Operator Type | inherit_context | accumulate_data | accumulation_format | fresh_context |
-|---------------|-----------------|-----------------|---------------------|---------------|
-| atomic        | full            | false           | notes_only          | enabled       |
-| sequential    | full            | true            | notes_only          | enabled       |
-| reduce        | none            | true            | notes_only          | enabled       |
-| script        | full            | false           | notes_only          | disabled      |
-| director_evaluator_loop | none  | true            | notes_only          | enabled       |
-
-These defaults apply when no explicit context_management block is provided. When present, the explicit settings override the defaults:
-
-```xml
-<context_management>
-    <inherit_context>full|none|subset</inherit_context>
-    <accumulate_data>true|false</accumulate_data>
-    <accumulation_format>notes_only|full_output</accumulation_format>
-    <fresh_context>enabled|disabled</fresh_context>
-</context_management>
-```
-
-The Task System delegates **all context management execution** to the Evaluator according to the final merged configuration. In other words:
-
-1. The Task System's role is to:
-   - Define task structure (sequential, map, reduce, etc.)
-   - Process context management configuration (defaults + overrides)
-   - Signal the Evaluator to execute steps with the final configuration
-
-2. The Evaluator manages all three dimensions of context:
-   - **inherit_context**: Controls parent context inheritance ("full", "none", or "subset").
-   - **accumulate_data**: Controls accumulation of previous step outputs (true/false).
-   - **accumulation_format**: Specifies storage format for accumulated data ("notes_only" or "full_output").
-   - **fresh_context**: Controls whether new context is generated via associative matching ("enabled" or "disabled").
-
-3. The Evaluator decides how and when to call `MemorySystem.getRelevantContextFor()` based on these settings.
-4. The Handler remains focused on resource tracking (turns, tokens).
-5. No direct context accumulation logic occurs in the Task System itself.
-
-## File Paths Feature
-
-The system supports an orthogonal file selection mechanism through the `file_paths` feature:
-
-### Feature Behavior
-- Available on all atomic tasks (both direct and subtasks)
-- Operates outside the standard three-dimensional context model
-- Specified files are always included in the context, regardless of other settings
-- Files are fetched by the Handler before task execution
-
-### Implementation Details
-- Files are retrieved using Handler tools
-- Both absolute paths and paths relative to repo root are supported
-- Files are presented in the context with XML tags indicating their paths
-- Invalid paths generate warnings but don't prevent task execution
-
-### Integration with Context Management
-- When used with `inherit_context="subset"`, specified files become the subset
-- When used with `fresh_context="enabled"`, specified files are forcibly included while associative matching still runs
-- The feature does not replace or disable other context management settings
-
-### XML Representation
-```xml
-<task type="atomic">
-  <description>Task description</description>
-  <context_management>
-    <!-- Standard context management settings -->
-  </context_management>
-  <file_paths>
-    <path>./src/main.py</path>
-    <path>/absolute/path/file.txt</path>
-  </file_paths>
-</task>
-```
-
-## Error Handling
-
-### Error Detection and Response
-
-#### Resource Exhaustion
-- Handler detects limit violations
-- Immediate task termination
-- Surfaces through standard error type
-- Resource accounting completion
-- Clean Handler termination
-- No retry attempts
-
-#### Invalid Output
-- Structural validation failure
-- Format validation errors
-- No semantic validation
-- Preserves partial outputs for diagnostic purposes
-- Returns both output and notes sections
-- Detailed error reporting with context
-
-#### Progress Failure
-- Handler detects stalled execution
-- Task-specific progress indicators
-- No internal progress tracking
-- Comprehensive error reporting
-- State preserved in error response
-- No automatic retry
-
-#### XML Validation
-- Immediate failure on invalid structure
-- No warning collection
-- Clear error messages
-- Location information when available
-- May trigger reparse if not disabled
-
-#### Partial Results Preservation
-
-The system preserves partial results for different task types to provide diagnostic context:
-
-1. **Atomic Tasks**
-   - Stores partial content in `notes.partialOutput`
-   - Preserves as much of the generated output as possible
-   - No structure guarantees for partial content
-   - Used for error reporting and diagnostics
-
-2. **Sequential Tasks**
-   - Stores step-by-step outputs in `details.partialResults`
-   - Includes metadata such as `failedStep` and `totalSteps`
-   - Each step result includes `stepIndex`, `output`, and optional `notes`
-   - Provides execution trace for debugging purposes
-
-3. **Reduce Tasks**
-   - Stores processed input results in `details.partialResults`
-   - Includes the current accumulator state in `details.currentAccumulator`
-   - Tracks processed inputs in `details.processedInputs`
-   - Records the failed input index in `details.failedInputIndex`
-   - Enables detailed error analysis
-
-#### Format Control
-
-The `accumulation_format` setting in the task's `context_management` block controls how much data is preserved:
-
-```xml
-<context_management>
-    <inherit_context>full</inherit_context>
-    <accumulate_data>true</accumulate_data>
-    <accumulation_format>notes_only|full_output</accumulation_format>
-    <fresh_context>enabled</fresh_context>
-</context_management>
-```
-
-- `notes_only`: Only the notes field is preserved (default for memory efficiency)
-- `full_output`: Both content and notes fields are preserved (with size limits)
-
-#### Size Management
-
-To prevent memory issues with partial results:
-- Individual outputs are kept reasonably sized
-- When accumulated data becomes too large, older results may be summarized or truncated
-- The system indicates when truncation has occurred in the error details
-- A maximum size cap applies regardless of settings
-
-### Error Response
-
-#### Error Surfacing
-- Uses standard error type system (see types.md)
-- Includes relevant task notes
-- Preserves partial outputs when useful
-- Includes resource metrics where applicable
-- Clear error messages and locations
-
-#### Handler Cleanup
-- Clean termination of LLM session
-- Resource accounting completion
-- No state preservation
-- Context window cleanup
-- Turn counter finalization
-
-#### Recovery Delegation
-- No retry attempts
-- Delegates to evaluator
-- Provides complete error context
-- Includes notes for recovery guidance
diff --git a/claude/docs/components/task-system/spec/interfaces.md b/claude/docs/components/task-system/spec/interfaces.md
deleted file mode 100644
index 490a1ce..0000000
--- a/claude/docs/components/task-system/spec/interfaces.md
+++ /dev/null
@@ -1,201 +0,0 @@
-# Task System Interfaces
-
-// For core type definitions (e.g. TaskResult, TaskTemplate, TaskType, AtomicTaskSubtype),
-// please refer to components/task-system/spec/types.md.
-
-import { MemorySystem } from "../../memory/api/interfaces";
-
-/**
- * TaskSystem Interface
- * 
- * Provides methods to execute tasks, validate templates, and find matching templates.
- */
-export interface TaskSystem {
-    /**
-     * Execute a task, automatically handling continuations via tool responses
-     * 
-     * If a task returns CONTINUATION status with a subtask_request:
-     * 1. The subtask is executed
-     * 2. The result is added as a tool response to the parent's session
-     * 3. The parent task continues execution with the tool result available
-     * 
-     * @param task - The task to execute
-     * @param memory - The Memory System instance
-     * @param taskType - Optional task type override
-     * @returns Promise resolving to the final task result
-     */
-    executeTask(
-        task: string,
-        memory: MemorySystem,
-        taskType?: "atomic" | "sequential" | "reduce" | "script"
-    ): Promise<TaskResult>;
-
-    validateTemplate(template: TaskTemplate): boolean;
-    
-    /**
-     * findMatchingTasks
-     *
-     * Finds matching templates based on a provided input string.
-     *
-     * Note: Matching applies *only* to atomic task templates. The function evaluates the input
-     * against atomic task templates using a heuristic scoring mechanism.
-     * 
-     * @param input - The natural language task description.
-     * @param context - The MemorySystem instance providing context data.
-     * @returns An array of matching candidates with their associated scores.
-     */
-    findMatchingTasks(
-        input: string,
-        context: MemorySystem
-    ): Promise<Array<{
-        template: TaskTemplate;
-        score: number;
-        taskType: "atomic" | "sequential" | "reduce" | "script";
-    }>>;
-    registerTask(taskDef: TaskDefinition): void;
-    executeFunctionCall(funcCall: FunctionCall, env: Environment): Promise<any>;
-    
-    /**
-     * Register a template in the TaskLibrary
-     * 
-     * @param template - The template to register
-     * @returns Promise resolving to registration result
-     */
-    registerTemplate(template: TemplateNode): Promise<void>;
-    
-    /**
-     * Execute a function call
-     * 
-     * @param call - The function call to execute
-     * @param env - The environment for argument evaluation
-     * @returns Promise resolving to the function result
-     */
-    executeCall(call: FunctionCallNode, env: Environment): Promise<TaskResult>;
-export interface Environment {
-    bindings: Record<string, any>;
-    outer?: Environment;
-    /**
-     * Perform a lexical lookup for varName.
-     * Returns the value if found; otherwise, throws an error.
-     */
-    find(varName: string): any;
-    executeScriptTask(scriptTask: ScriptTask, env: Environment): Promise<ScriptTaskResult>;
-    
-    /**
-     * Create a new child environment with additional bindings
-     * 
-     * @param bindings - New variable bindings to add
-     * @returns A new Environment with the added bindings
-     */
-    extend(bindings: Record<string, any>): Environment;
-}
-
-// Handler interface details are maintained in external documentation.
- * Memory System interface - Version 3.0
- * Provides metadata management and context retrieval
- * Follows a read-only context model (no updateContext capability)
- */
-type FileMetadata = string;
-
-type GlobalIndex = Map<string, FileMetadata>;
-
-type FileMatch = [string, string | undefined];
-
-interface AssociativeMatchResult {
-    context: string;      // Unstructured data context
-    matches: FileMatch[]; // Relevant file matches
-}
-
-interface MemorySystem {
-    // Get global file metadata index
-    getGlobalIndex(): Promise<GlobalIndex>;
-    
-    // Update global file metadata index
-    updateGlobalIndex(index: GlobalIndex): Promise<void>;
-    
-    // Retrieve context using associative matching
-    getRelevantContextFor(input: ContextGenerationInput): Promise<AssociativeMatchResult>;
-}
-```
-
-### Example Definitions
-
-**ContextGenerationInput Example:**
-```json
-{
-    "taskText": "Analyze experimental data",
-    "inheritedContext": "Optional inherited context from previous tasks (if not disabled)",
-    "previousOutputs": "Optional string summarizing prior outputs"
-}
-```
-
-**AssociativeMatchResult Example:**
-```json
-{
-    "context": "Relevant retrieved context information",
-    "matches": [
-        ["fileA.txt", "metadata details"],
-        ["fileB.txt", null]
-    ]
-}
-```
-
-### Handler Interface
-```typescript
-/**
- * Types specific to Handler interface
- */
-interface HandlerConfig {
-    maxTurns: number;
-    maxContextWindowFraction: number;
-    defaultModel?: string;
-    systemPrompt: string;
-}
-
-/**
- * LLM interaction interface
- * Uses [Type:TaskSystem:ResourceMetrics:1.0], [Type:TaskSystem:ResourceLimits:1.0]
- */
-interface Handler {
-    /**
-     * Execute a prompt with the LLM
-     * Note: All template substitution should be performed by the Evaluator before calling
-     * @param systemPrompt - System-level context and instructions (fully resolved)
-     * @param taskPrompt - Task-specific input (fully resolved)
-     * @returns Promise resolving to LLM response
-     */
-    executePrompt(
-        systemPrompt: string,
-        taskPrompt: string
-    ): Promise<string>;
-
-    /**
-     * Register a direct tool that will be executed by the Handler
-     * @param name - Unique tool name
-     * @param handler - Function that implements the tool
-     */
-    registerDirectTool(name: string, handler: Function): void;
-
-    /**
-     * Register a subtask tool that will be implemented via CONTINUATION
-     * @param name - Unique tool name
-     * @param templateHints - Hints for template selection
-     */
-    registerSubtaskTool(name: string, templateHints: string[]): void;
-
-    /**
-     * Add a tool response to the session
-     * Used for adding subtask results to parent tasks
-     * @param toolName - Name of the tool that produced the response
-     * @param response - The tool response content
-     */
-    addToolResponse(toolName: string, response: string): void;
-
-    /**
-     * Callback for handling agent input requests
-     * @param agentRequest - The agent's request for user input
-     * @returns Promise resolving to user's input
-     */
-    onRequestInput: (agentRequest: string) => Promise<string>;
-}
-```
diff --git a/claude/docs/system/contracts/protocols.md b/claude/docs/system/contracts/protocols.md
index 0e958b6..286db03 100644
--- a/claude/docs/system/contracts/protocols.md
+++ b/claude/docs/system/contracts/protocols.md
@@ -1,5 +1,14 @@
 # System Protocols
 
+## Overview
+
+This document defines the core protocols used throughout the system for task execution, communication, and integration. It includes:
+
+- XML schema for task templates
+- Subtask spawning protocol
+- LLM interaction protocol
+- Cross-component communication standards
+
 ## Task Template Schema [Contract:Tasks:TemplateSchema:1.0]
 
 **Note:** This document is the authoritative specification for the XML schema used in task template definitions. All field definitions, allowed enumerations (such as for `<inherit_context>` and `<accumulation_format>`), and validation rules are defined here. For complete validation guidelines, please see Appendix A in [Contract:Resources:1.0].
@@ -278,6 +287,63 @@ Output validation ensures the result matches the specified type.
 
 The subtask spawning protocol defines how tasks can dynamically create and execute subtasks.
 
+### Request Structure
+
+```typescript
+interface SubtaskRequest {
+  // Required fields
+  type: TaskType;                      // Type of subtask to spawn
+  description: string;                 // Description of the subtask
+  inputs: Record<string, any>;         // Input parameters for the subtask
+  
+  // Optional fields
+  template_hints?: string[];           // Hints for template selection
+  context_management?: {               // Override default context settings
+    inherit_context?: 'full' | 'none' | 'subset';
+    accumulate_data?: boolean;
+    accumulation_format?: 'notes_only' | 'full_output';
+    fresh_context?: 'enabled' | 'disabled';
+  };
+  max_depth?: number;                  // Override default max nesting depth
+  subtype?: string;                    // Optional subtype for atomic tasks
+  file_paths?: string[];               // Specific files to include in context
+}
+```
+
+### Execution Flow
+
+1. **Request Generation**: A parent task returns a result with `status: "CONTINUATION"` and includes a `subtask_request` in its notes.
+
+2. **Request Validation**: The system validates the subtask request structure, ensuring all required fields are present and correctly formatted.
+
+3. **Template Selection**: The system selects an appropriate template based on:
+   - The `type` and optional `subtype` fields
+   - The `description` field for associative matching
+   - Any provided `template_hints`
+
+4. **Depth Control**: The system checks:
+   - Current nesting depth against maximum allowed depth (default: 5)
+   - Cycle detection to prevent recursive spawning of identical tasks
+   - Resource usage across the entire subtask chain
+
+5. **Subtask Execution**: The system executes the subtask with:
+   - Direct parameter passing from the `inputs` field
+   - Context management according to defaults or overrides
+   - Resource tracking linked to the parent task
+
+6. **Result Handling**: The subtask result is passed back to the parent task when execution resumes, with the parent receiving the complete TaskResult structure.
+
+### Default Context Management Settings
+
+Subtasks have specific default context management settings:
+
+| Setting | Default Value | Description |
+|---------|---------------|-------------|
+| inherit_context | subset | Inherits only relevant context from parent |
+| accumulate_data | false | Does not accumulate previous step outputs |
+| accumulation_format | notes_only | Stores only summary information |
+| fresh_context | enabled | Generates new context via associative matching |
+
 ## LLM Interaction Protocol [Protocol:LLMInteraction:1.0]
 
 The Handler-LLM interaction follows a standardized protocol using the `HandlerPayload` structure:
@@ -477,16 +543,35 @@ The `<context_management>` element controls how context is managed during task e
 </context_management>
 ```
 
-### Context Management Constraints
+## XML Validation Rules
 
-The following constraints apply to context management settings:
+### Required Field Validation
+- All required fields must be present
+- Input names must be unique
+- Boolean fields must be "true" or "false"
+- Model must be a valid LLM identifier
 
+### Context Management Constraints
 1. **Mutual Exclusivity**: `fresh_context="enabled"` cannot be combined with `inherit_context="full"` or `inherit_context="subset"`
    - If `inherit_context` is "full" or "subset", `fresh_context` must be "disabled"
    - If `fresh_context` is "enabled", `inherit_context` must be "none"
 
 2. **Validation Errors**: Templates violating these constraints will fail validation with clear error messages
 
+### Function Template Validation
+- Template names must be unique within the TaskLibrary
+- Parameter lists must use valid identifiers
+- Templates must have a valid body task
+- Function calls must reference existing templates
+- Argument counts must match parameter counts
+
+## Related Documentation
+
+For implementation details, see:
+- [XML Processing Implementation](../../components/task-system/impl/xml-processing.md)
+- [Function Template Examples](../../components/task-system/impl/examples/function-templates.md)
+- [Subtask Spawning Examples](../../components/task-system/impl/examples/subtask-spawning.md)
+
 Each operator type has specific default settings that apply when the `<context_management>` element is omitted:
 
 | Operator Type | inherit_context | accumulate_data | accumulation_format | fresh_context |
diff --git a/index.md b/index.md
new file mode 100644
index 0000000..0b17f2c
--- /dev/null
+++ b/index.md
@@ -0,0 +1,57 @@
+# System Documentation
+    
+This document provides the main entry point to all system documentation.
+    
+## System Overview
+    
+- [System README](./system/README.md) - High-level system overview and architecture
+- [Architecture Overview](./system/architecture/overview.md) - Detailed architecture description
+    
+## Component Documentation
+    
+- [Component Index](./components/index.md) - Index of all system components
+- [Task System](./components/task-system/README.md) - Task execution and management
+- [Memory System](./components/memory/README.md) - Context management and retrieval
+- [Evaluator](./components/evaluator/README.md) - Task execution and variable resolution
+- [Compiler](./components/compiler/README.md) - Natural language to structured task translation
+    
+## Architecture Patterns
+    
+- [Pattern Index](./system/architecture/patterns/index.md) - Index of all architectural patterns
+- [Director-Evaluator Pattern](./system/architecture/patterns/director-evaluator.md) - Iterative refinement pattern
+- [Error Handling Pattern](./system/architecture/patterns/errors.md) - Error detection and recovery
+- [Context Frame Pattern](./system/architecture/patterns/context-frames.md) - Context management model
+- [Resource Management Pattern](./system/architecture/patterns/resource-management.md) - Resource tracking and limits
+- [Tool Interface Pattern](./system/architecture/patterns/tool-interface.md) - Unified tool interface with different implementations
+    
+## Architecture Decisions
+    
+- [ADR Index](./system/architecture/decisions/index.md) - Index of all Architecture Decision Records
+    
+## Contracts and Integration
+    
+- [System Contracts](./system/contracts/interfaces.md) - Cross-component interfaces
+    - [System Protocols](./system/contracts/protocols.md) - XML schema and protocols
+    - [Resource Contracts](./system/contracts/resources.md) - Resource management contracts
+    - [Integration Documentation](./system/integration/index.md) - Cross-component integration
+    
+## Questions and Answers
+
+- [Q&A Index](./system/qa/index.md) - Index of questions and answers
+- [Architecture Questions](./system/qa/architecture-questions.md) - High-level architecture questions
+- [Component FAQ](./system/qa/component-faq.md) - Component-specific questions
+
+## Implementation
+
+- [Implementation Plan](./system/planning/implementation-plan.md) - Consolidated implementation priorities and timeline
+
+## Cross-Reference Standard
+
+This documentation uses a consistent cross-reference format:
+
+- Types: `[Type:Component:Name:Version]` (e.g., `[Type:TaskSystem:TaskResult:1.0]`)
+- Interfaces: `[Interface:Component:Name:Version]` (e.g., `[Interface:Memory:3.0]`)
+- Contracts: `[Contract:Category:Name:Version]` (e.g., `[Contract:Integration:TaskMemory:3.0]`)
+- Patterns: `[Pattern:Name:Version]` (e.g., `[Pattern:DirectorEvaluator:1.1]`)
+
+Each reference points to an authoritative source document where the referenced entity is defined.
diff --git a/system/integration/cross-component.md b/system/integration/cross-component.md
new file mode 100644
index 0000000..2efcbc5
--- /dev/null
+++ b/system/integration/cross-component.md
@@ -0,0 +1,174 @@
+# Cross-Component Integration
+    
+This document describes how system components interact with each other.
+    
+## Task System ↔ Evaluator
+    
+### Responsibilities
+    
+**Task System:**
+- Selects and provides templates
+- Creates Handler instances
+- Manages resource limits
+- Coordinates overall execution
+    
+**Evaluator:**
+- Resolves template variables
+- Manages execution context
+- Handles function calls
+- Manages variable bindings
+    
+### Integration Points
+    
+- Task System delegates template variable resolution to Evaluator
+- Evaluator executes the task using Handler provided by Task System
+- Task System handles template matching and selection
+- Evaluator manages execution context and variable bindings
+    
+### Data Flow
+    
+```
+Task System → Provides template → Evaluator
+Evaluator → Resolves variables → Task System
+Task System → Creates Handler → Evaluator
+Evaluator → Executes through Handler → Task System
+```
+    
+## Task System ↔ Memory
+    
+### Responsibilities
+    
+**Task System:**
+- Uses context for task execution
+- Receives file references via associative matching
+- Delegates file access to Handler tools
+    
+**Memory System:**
+- Maintains global file metadata index
+- Provides context for associative matching
+- Supplies metadata for file-based lookup
+- Does NOT store file content or perform file operations
+    
+### Integration Points
+    
+- Task System requests context via `getRelevantContextFor`
+- Memory System provides metadata and file paths
+- Task System uses Handler tools for file access
+- No direct interaction with file content in Memory System
+    
+### Data Flow
+    
+```
+Task System → Context request → Memory System
+Memory System → Metadata and file paths → Task System
+Task System → File paths → Handler tools
+Handler tools → File content → Task System
+```
+    
+## Evaluator ↔ Memory
+    
+### Responsibilities
+    
+**Evaluator:**
+- Manages context for task execution
+- Uses Memory System for associative matching
+- Controls context inheritance between tasks
+    
+**Memory System:**
+- Provides context based on task description
+- Returns relevant file paths
+- Does not track resources or rank matches
+    
+### Integration Points
+    
+- Evaluator requests context based on task description
+- Memory System returns relevant context and file paths
+- Evaluator manages context flow between tasks
+- No direct file access in Memory System
+    
+### Data Flow
+    
+```
+Evaluator → Context request → Memory System
+Memory System → Context and file paths → Evaluator
+Evaluator → Context to task → Handler
+```
+    
+## Compiler ↔ Task System
+    
+### Responsibilities
+    
+**Compiler:**
+- Translates natural language to structured tasks
+- Validates task structure
+- Generates XML or AST representation
+    
+**Task System:**
+- Executes compiled tasks
+- Manages template registration
+- Coordinates resources for execution
+    
+### Integration Points
+    
+- Compiler provides structured tasks to Task System
+- Task System executes tasks using appropriate components
+- Compiler validates task structure before execution
+    
+### Data Flow
+    
+```
+Natural Language → Compiler → Structured Task
+Compiler → Structured Task → Task System
+Task System → Template Registration → TaskLibrary
+Task System → Execution → Handler and Evaluator
+```
+    
+## Responsibility Boundaries
+    
+### File Operations
+    
+- **Memory System**: Manages ONLY file metadata (paths and descriptions)
+- **Handler**: Performs ALL file I/O operations
+- **Task System**: Coordinates file operations via Handler tools
+- **Evaluator**: Uses file content for task execution
+    
+### Resource Management
+    
+- **Handler**: Tracks and enforces resource limits
+- **Task System**: Configures resource limits
+- **Evaluator**: Makes decisions based on resource constraints
+- **Memory System**: No resource tracking responsibility
+    
+### Template Management
+    
+- **Task System**: Manages template registration and selection
+- **Compiler**: Validates and transforms templates
+- **Evaluator**: Resolves template variables
+- **Handler**: No template responsibilities
+    
+## Error Handling Across Components
+    
+### Resource Exhaustion
+    
+1. **Handler** detects resource exhaustion
+2. **Handler** returns error to **Evaluator**
+3. **Evaluator** decides on recovery strategy
+4. **Task System** receives error if recovery fails
+    
+### Context Failures
+    
+1. **Memory System** returns error for context retrieval failure
+2. **Evaluator** receives error and attempts recovery
+3. **Task System** receives error if recovery fails
+    
+### Execution Failures
+    
+1. **Handler** detects execution failure
+2. **Evaluator** receives error and decides on recovery
+3. **Task System** receives error if recovery fails
+    
+## Related Documentation
+    
+- [Component Interfaces](../contracts/interfaces.md)
+- [Resource Management Pattern](../architecture/patterns/resource-management.md)
+- [Error Handling Pattern](../architecture/patterns/errors.md)
diff --git a/system/integration/index.md b/system/integration/index.md
new file mode 100644
index 0000000..4efe8e7
--- /dev/null
+++ b/system/integration/index.md
@@ -0,0 +1,23 @@
+# Integration Documentation [Index]
+    
+This document provides an index to cross-component integration documentation.
+    
+## Integration Documents
+    
+- [Cross-Component Integration](./cross-component.md) - Interactions between system components
+    
+## Organization
+    
+Integration documentation focuses on the interactions between components, ensuring clear responsibility boundaries and consistent interfaces. Each document covers:
+    
+- Integration points between components
+- Responsibility boundaries
+- Data flow between components
+- Error handling across component boundaries
+    
+## Related Documentation
+    
+- [Component Interfaces](../contracts/interfaces.md)
+- [Resource Contracts](../contracts/resources.md)
+- [System Protocols](../contracts/protocols.md)
+- [Component Index](../../components/index.md)
diff --git a/system/planning/implementation-plan.md b/system/planning/implementation-plan.md
new file mode 100644
index 0000000..1a7cbe4
--- /dev/null
+++ b/system/planning/implementation-plan.md
@@ -0,0 +1,118 @@
+# Implementation Plan
+    
+This document consolidates implementation priorities and tracks status.
+    
+## Completed Tasks
+    
+### Architecture Foundations
+    
+- ✅ **Context Management Standardization** - Implemented in [ADR 14: Operator Context Configuration](../architecture/decisions/completed/014-operator-ctx-config.md)
+- ✅ **Error Taxonomy for Context Issues** - Implemented in [ADR 8: Error Taxonomy](../architecture/decisions/8-errors.md)
+- ✅ **Partial Results Policy** - Implemented in [ADR 9: Partial Results Policy](../architecture/decisions/completed/009-partial-results.md)
+- ✅ **Evaluator-to-Director Feedback Flow** - Implemented in [ADR 10: Evaluator-to-Director Feedback Flow](../architecture/decisions/completed/010-evaluator-director.md)
+- ✅ **Subtask Spawning Mechanism** - Implemented in [ADR 11: Subtask Spawning Mechanism](../architecture/decisions/completed/011-subtask-spawning.md)
+- ✅ **Function-Based Templates** - Implemented in [ADR 12: Function-Based Templates](../architecture/decisions/completed/012-function-based-templates.md)
+- ✅ **JSON-based Output Standardization** - Implemented in [ADR 13: JSON Output](../architecture/decisions/completed/013-json-output.md)
+    
+### Core Patterns
+    
+- ✅ **Director-Evaluator Pattern** - Documented in [Pattern:DirectorEvaluator:1.1](../architecture/patterns/director-evaluator.md)
+- ✅ **Error Handling Pattern** - Documented in [Pattern:Error:1.0](../architecture/patterns/errors.md)
+- ✅ **Context Frame Pattern** - Documented in [Pattern:ContextFrame:1.0](../architecture/patterns/context-frames.md)
+- ✅ **Resource Management Pattern** - Documented in [Pattern:ResourceManagement:1.0](../architecture/patterns/resource-management.md)
+- ✅ **Tool Interface Pattern** - Documented in [Pattern:ToolInterface:1.0](../architecture/patterns/tool-interface.md)
+    
+### Interface Definitions
+    
+- ✅ **Memory System Interface** - Defined in [Interface:Memory:3.0](../../components/memory/api/interfaces.md)
+- ✅ **Task System Interface** - Defined in [Interface:TaskSystem:1.0](../../components/task-system/api/interfaces.md)
+- ✅ **Handler Interface** - Defined in system/contracts/interfaces.md
+    
+## Current Priorities
+    
+### Implementation Phase 1: Core Components
+    
+1. **Memory System Implementation**
+   - Implement global index management
+   - Implement associative matching
+   - Implement context retrieval
+   - References: [Interface:Memory:3.0](../../components/memory/api/interfaces.md)
+    
+2. **Task System Implementation**
+   - Implement template matching
+   - Implement resource management
+   - Implement XML processing
+   - References: [Implementation Design](../../components/task-system/impl/design.md)
+    
+3. **Evaluator Implementation**
+   - Implement template variable substitution
+   - Implement function call processing
+   - Implement context management
+   - References: [Evaluator Design](../../components/evaluator/impl/design.md)
+    
+4. **Handler Implementation**
+   - Implement resource tracking
+   - Implement LLM interaction
+   - Implement tool interface
+   - References: [Resource Management Implementation](../../components/task-system/impl/resource-management.md)
+    
+### Implementation Phase 2: Integration
+    
+1. **Component Integration**
+   - Implement cross-component communication
+   - Implement error handling across boundaries
+   - Implement resource management coordination
+   - References: [Cross-Component Integration](../integration/cross-component.md)
+    
+2. **Pattern Implementation**
+   - Implement Director-Evaluator pattern
+   - Implement Subtask Spawning mechanism
+   - Implement Tool Interface pattern
+   - References: [Pattern Index](../architecture/patterns/index.md)
+    
+## Future Tasks
+    
+### Advanced Features
+    
+1. **Multiple Tries/Selection of Best Candidate Result**
+   - Design mechanism for generating multiple solution candidates
+   - Implement evaluation criteria
+   - Create selection process for best results
+   - Status: Unresolved question in [Architecture Questions](../qa/architecture-questions.md)
+    
+2. **Agent Features**
+   - Design storage for agent conversation history
+   - Create REPL interface for interactive task execution
+   - Integrate with existing components
+   - Status: Unresolved question in [Architecture Questions](../qa/architecture-questions.md)
+    
+3. **Multi-LLM Support**
+   - Design abstraction layer for different LLM providers
+   - Implement adapters for each provider's API
+   - Ensure consistent behavior across models
+   - Status: Unresolved question in [Architecture Questions](../qa/architecture-questions.md)
+    
+## Implementation Timeline
+    
+- **Phase 1: Core Components** - 8-10 weeks
+  - Memory System: 2-3 weeks
+  - Task System: 3-4 weeks
+  - Evaluator: 2-3 weeks
+  - Handler: 1-2 weeks
+    
+- **Phase 2: Integration** - 4-6 weeks
+  - Component Integration: 2-3 weeks
+  - Pattern Implementation: 2-3 weeks
+    
+- **Phase 3: Advanced Features** - Timeline TBD based on prioritization
+    
+## Status Tracking
+    
+| Task | Status | References | Estimated Completion |
+|------|--------|------------|----------------------|
+| Memory System Implementation | In Progress | [Interface:Memory:3.0] | Week 3 |
+| Task System Implementation | Planning | [Implementation Design] | Week 7 |
+| Evaluator Implementation | Not Started | [Evaluator Design] | Week 10 |
+| Handler Implementation | Not Started | [Resource Management] | Week 12 |
+| Component Integration | Not Started | [Cross-Component Integration] | Week 15 |
+| Pattern Implementation | Not Started | [Pattern Index] | Week 18 |
diff --git a/system/qa/architecture-questions.md b/system/qa/architecture-questions.md
new file mode 100644
index 0000000..fd15cd5
--- /dev/null
+++ b/system/qa/architecture-questions.md
@@ -0,0 +1,98 @@
+# Architecture Questions
+    
+This document tracks architecture-level questions, both resolved and unresolved.
+    
+## Resolved Questions
+    
+### Context Management
+    
+**Q: How is context inherited in complex tasks?**  
+A: Context inheritance is controlled by the three-dimensional context management model:
+- `inherit_context`: Controls whether a task inherits "full" parent context, "none", or a "subset" based on relevance
+- `accumulate_data`: Controls whether outputs from prior steps are accumulated
+- `fresh_context`: Controls whether new context is generated via associative matching
+    
+See [ADR 14: Operator Context Configuration](../architecture/decisions/completed/014-operator-ctx-config.md) for the complete decision.
+    
+**Q: Should rebuild-memory and clear-memory flags be added?**  
+A: No. The same functionality can be achieved through appropriate configuration of `<inherit_context>`, `<accumulate_data>`, and `<fresh_context>` settings. Adding separate flags would be redundant.
+    
+**Q: How should context inheritance work in reduce operations?**  
+A: The `reduce` operator now supports the same context management model as other operators, with different defaults:
+- `inherit_context`: "none" (default)
+- `accumulate_data`: "true" (default)
+- `fresh_context`: "enabled" (default)
+    
+See [ADR 14: Operator Context Configuration](../architecture/decisions/completed/014-operator-ctx-config.md) for details.
+    
+### Error Handling
+    
+**Q: Should there be a distinct error type for context failures?**  
+A: No. Context failures are categorized under the standard `TASK_FAILURE` type with specific reason codes:
+- `context_retrieval_failure`: Failure to retrieve context data
+- `context_matching_failure`: Failure in associative matching algorithm
+- `context_parsing_failure`: Failure to parse or process retrieved context
+    
+See [ADR 8: Error Taxonomy](../architecture/decisions/8-errors.md) for the complete decision.
+    
+**Q: How should partial results be handled on failure?**  
+A: Partial results are preserved in standardized error structures specific to each task type:
+- Atomic tasks: Store partial content in `content` field with FAILED status
+- Sequential tasks: Store step outputs in `details.partialResults` array
+- Reduce tasks: Store processed inputs and current accumulator
+    
+See [ADR 9: Partial Results Policy](../architecture/decisions/completed/009-partial-results.md) for details.
+    
+### Component Integration
+    
+**Q: How should Director and Evaluator components interact?**  
+A: The Director-Evaluator pattern now supports both dynamic and static variants with direct parameter passing:
+- Dynamic: Director returns CONTINUATION status with evaluation_request
+- Static: Predefined director_evaluator_loop task type with explicit components
+    
+See [ADR 10: Evaluator-to-Director Feedback Flow](../architecture/decisions/completed/010-evaluator-director.md) for details.
+    
+**Q: Should subtasks use environment variables or direct parameter passing?**  
+A: Direct parameter passing. Subtasks use a standardized SubtaskRequest structure with explicit inputs, and results are passed back directly through the task return value. Environment variables are not used for data flow.
+    
+See [ADR 11: Subtask Spawning Mechanism](../architecture/decisions/completed/011-subtask-spawning.md) for details.
+    
+**Q: What is the boundary between tools and subtasks?**  
+A: Tools are Handler-managed operations with deterministic APIs, while subtasks are LLM-to-LLM interactions using the continuation mechanism. The Unified Tool Interface pattern provides a consistent interface for both, with different implementation strategies.
+    
+See [Pattern:ToolInterface:1.0](../architecture/patterns/tool-interface.md) for details.
+    
+## Unresolved Questions
+    
+### 1. Genetic Testing Approach
+    
+**Q: How should multiple solution candidates be generated and evaluated?**  
+    
+This remains an open design area focused on:
+- Generating multiple solution approaches to the same problem
+- Evaluating each approach against defined criteria
+- Selecting the best solution based on evaluation results
+    
+This may be implemented as an extension of the Director-Evaluator pattern or as a new pattern entirely.
+    
+### 2. Agent-Style Workflow Patterns
+    
+**Q: How should the system implement conversation → JSON → map spec prompts workflow?**
+    
+This workflow pattern would allow:
+- Converting natural language conversation to structured data
+- Using that data to generate specification prompts
+- Executing those prompts in parallel
+    
+The implementation details and integration with existing patterns are still under consideration.
+    
+### 3. Multi-LLM Coordination
+    
+**Q: How should the system coordinate different LLM types for specialized tasks?**
+    
+This question involves:
+- Selecting appropriate LLM types for different subtasks
+- Managing context flow between different LLM providers
+- Optimizing resource usage across multiple LLMs
+    
+This may require extensions to the Handler abstraction and Provider-specific adapters.
diff --git a/system/qa/component-faq.md b/system/qa/component-faq.md
new file mode 100644
index 0000000..78f30d4
--- /dev/null
+++ b/system/qa/component-faq.md
@@ -0,0 +1,59 @@
+# Component Frequently Asked Questions
+    
+This document provides answers to frequently asked questions about system components.
+    
+## Task System
+    
+**Q: How many Handlers should be created per task execution?**  
+A: One Handler per task execution. See [Task System Requirements](../../components/task-system/spec/requirements.md) for details.
+    
+**Q: Who is responsible for sending prompts to the LLM?**  
+A: The Handler is responsible for all LLM interactions.
+    
+**Q: How are resource limits enforced?**  
+A: Resource limits are passed to the Handler at initialization and enforced during execution. For more details, see [Resource Management Implementation](../../components/task-system/impl/resource-management.md).
+    
+**Q: Which task types participate in template matching?**  
+A: Only atomic task templates participate in the template matching process used for task selection based on natural language descriptions. All task types can be defined as templates, but only atomic tasks are matched for selection.
+    
+## Memory System
+    
+**Q: What exactly constitutes working memory?**  
+A: The Memory System only manages two types of data:
+1. Short-term task data context generated by associative matching
+2. Global file metadata index for bootstrapping associative matching
+    
+The Handler manages all other task-related data including chat history and prompt handling.
+    
+**Q: How is "context" different from "working memory"?**  
+A: "Context" specifically refers to data context, while working memory is broader and includes chat history, system prompts, and templates. See [Pattern:ContextFrame:1.0](../../system/architecture/patterns/context-frames.md) for details.
+    
+**Q: What exactly does associative matching return?**  
+A: Associative matching has two specific return values:
+1. An unstructured data context section
+2. A list of tuples containing absolute file paths and optional index strings for those files
+    
+**Q: Should the memory system track context window size?**  
+A: No, this is delegated to the Handler (see [Interface:Handler:ResourceMonitoring:1.0]). The memory system stores content but doesn't track usage limits.
+    
+**Q: Who handles file content access?**  
+A: File content access is handled by the LLM using Handler tools, not by the Memory System. The Memory System only provides the file paths and metadata needed to identify relevant files.
+    
+## Evaluator
+    
+**Q: Who is responsible for template variable substitution?**  
+A: The Evaluator is solely responsible for resolving all template variables (e.g., `{{variable_name}}` placeholders) before passing tasks to the Handler for execution.
+    
+**Q: How are function templates different from standard templates?**  
+A: Function templates explicitly declare their parameters and create isolated environments where only those parameters are accessible. Standard templates have access to the entire lexical environment. See [ADR 12: Function-Based Templates](../../system/architecture/decisions/completed/012-function-based-templates.md).
+    
+**Q: How does the Evaluator handle resource constraints?**  
+A: The Evaluator delegates resource tracking to the Handler but makes decisions about continuation and task decomposition based on resource errors.
+    
+## Compiler
+    
+**Q: What is the Compiler's primary responsibility?**  
+A: The Compiler translates natural language inputs into structured task representations (XML or AST) that can be executed by the system.
+    
+**Q: How does the Compiler interact with the Task System?**  
+A: The Compiler provides parsed task definitions to the Task System, which then executes them using the appropriate Handler and Evaluator components.
diff --git a/system/qa/index.md b/system/qa/index.md
new file mode 100644
index 0000000..afbabed
--- /dev/null
+++ b/system/qa/index.md
@@ -0,0 +1,21 @@
+# Questions and Answers [Index]
+    
+This document provides an index to questions and answers across the system architecture and components.
+    
+## Q&A Categories
+    
+- [Architecture Questions](./architecture-questions.md) - High-level architecture questions and open issues
+- [Component FAQ](./component-faq.md) - Frequently asked questions about specific components
+    
+## Organization
+    
+Questions have been organized by scope and component to improve navigation and clarity:
+    
+- **Architecture Questions**: Focus on cross-cutting concerns, design decisions, and architectural patterns
+- **Component FAQ**: Specific questions about component functionality, responsibilities, and implementation details
+    
+## Related Documentation
+    
+- [Architecture Decision Records](../architecture/decisions/index.md)
+- [Architecture Patterns](../architecture/patterns/index.md)
+- [Component Documentation](../../components/index.md)
