# Component Frequently Asked Questions
    
This document provides answers to frequently asked questions about system components.
    
## Task System
    
**Q: How many Handlers should be created per task execution?**  
A: One Handler per task execution. See [Task System Requirements](../../components/task-system/spec/requirements.md) for details.
    
**Q: Who is responsible for sending prompts to the LLM?**  
A: The Handler is responsible for all LLM interactions.
    
**Q: How are resource limits enforced?**  
A: Resource limits are passed to the Handler at initialization and enforced during execution. For more details, see [Resource Management Implementation](../../components/task-system/impl/resource-management.md).
    
**Q: Which task types participate in template matching?**  
A: Only atomic task templates participate in the template matching process used for task selection based on natural language descriptions. All task types can be defined as templates, but only atomic tasks are matched for selection.
    
## Memory System
    
**Q: What exactly constitutes working memory?**  
A: The Memory System only manages two types of data:
1. Short-term task data context generated by associative matching
2. Global file metadata index for bootstrapping associative matching
    
The Handler manages all other task-related data including chat history and prompt handling.
    
**Q: How is "context" different from "working memory"?**  
A: "Context" specifically refers to data context, while working memory is broader and includes chat history, system prompts, and templates. See [Pattern:ContextFrame:1.0](../../system/architecture/patterns/context-frames.md) for details.
    
**Q: What exactly does associative matching return?**  
A: Associative matching has two specific return values:
1. An unstructured data context section
2. A list of tuples containing absolute file paths and optional index strings for those files
    
**Q: Should the memory system track context window size?**  
A: No, this is delegated to the Handler (see [Interface:Handler:ResourceMonitoring:1.0]). The memory system stores content but doesn't track usage limits.
    
**Q: Who handles file content access?**  
A: File content access is handled by the LLM using Handler tools, not by the Memory System. The Memory System only provides the file paths and metadata needed to identify relevant files.

**Q: How does the Memory System handle very large repositories?**  
A: The Memory System supports token-based sharded context retrieval for large repositories. It estimates token counts for metadata, divides the global index into optimally sized shards, and processes shards in parallel. This approach maintains performance while still returning all relevant matches without filtering or prioritization.

**Q: Is there a limit to how many files the Memory System can handle?**  
A: The Memory System is designed to scale with repository size through its sharded retrieval approach. Performance is maintained by dividing the workload based on estimated token counts rather than file counts, making it suitable for repositories of any size within system resource constraints.
    
## Evaluator
    
**Q: Who is responsible for template variable substitution?**  
A: The Evaluator is solely responsible for resolving all template variables (e.g., `{{variable_name}}` placeholders) before passing tasks to the Handler for execution.
    
**Q: How are function templates different from standard templates?**  
A: Function templates explicitly declare their parameters and create isolated environments where only those parameters are accessible. Standard templates have access to the entire lexical environment. See [ADR 12: Function-Based Templates](../../system/architecture/decisions/completed/012-function-based-templates.md).
    
**Q: How does the Evaluator handle resource constraints?**  
A: The Evaluator delegates resource tracking to the Handler but makes decisions about continuation and task decomposition based on resource errors.
    
## Compiler
    
**Q: What is the Compiler's primary responsibility?**  
A: The Compiler translates natural language inputs into structured task representations (XML or AST) that can be executed by the system.
    
**Q: How does the Compiler interact with the Task System?**  
A: The Compiler provides parsed task definitions to the Task System, which then executes them using the appropriate Handler and Evaluator components.
