**PRD: Programmatic Workflows via S-Expression Syntax (MVP)**

**1. Introduction**

*   **Problem:** The current `/task type:subtype param=value` command allows invoking pre-defined tasks or tools but lacks the ability for users to define and execute multi-step, compositional workflows directly from the command line or programmatically. Expressing data pipelines (e.g., generate data -> process data items -> aggregate results) requires creating dedicated TaskSystem templates.
*   **Proposed Solution:** Introduce support for defining and executing workflows using a concise, functional S-expression syntax (inspired by Lisp/Scheme) directly within the `/task` command. This initial version (MVP) will focus on direct task invocation (`call`) and mapping operations (`map`) using nested composition for data flow.
*   **Benefit:** Provide developers with a powerful, flexible, programmatic way to orchestrate tasks and compose simple data pipelines directly from the REPL or API calls, without needing pre-defined templates for every workflow.

**2. Goals**

*   Allow users to define workflows programmatically using a minimal S-expression syntax via the `/task` command.
*   Support direct invocation of registered Handler Direct Tools and TaskSystem Templates (`call`).
*   Support mapping a specific task over a list of items generated by a nested expression (`map`).
*   Enable data flow between nested calls implicitly (output of inner call becomes input to outer function/map).
*   Support dynamic context retrieval (files, history) within the workflow expression (`get_context`).
*   Provide clear error reporting for S-expression syntax and evaluation errors.
*   Integrate seamlessly with existing task/tool execution mechanisms.

**3. Non-Goals (for this MVP)**

*   Implementing a full Lisp/Scheme interpreter.
*   Supporting `bind` or `let` for explicit variable assignment within the S-expression.
*   Supporting `sequence` for executing multiple top-level expressions for side effects.
*   Supporting advanced Lisp features (macros, lambda, continuations, complex data structures beyond lists/basic types).
*   Providing a graphical workflow editor.
*   Replacing the XML/YAML template system.
*   Sophisticated S-expression debugging tools.
*   Built-in support for concurrency within `map`.

**4. Target Audience**

*   Developers using the framework via the REPL interface for scripting multi-step tasks.
*   Developers building applications/agents needing programmatic workflow definition.

**5. User Stories (MVP Focus)**

*   **US-SE-1 (Simple Call):** As a developer, I want to run `/task '(call math:add (x 5) (y 10))'` so that I can execute a simple registered task using S-expression syntax.
*   **US-SE-2 (Nested Call):** As a developer, I want to run `/task '(call task1 (arg1 "value") (arg2 (call task2 "inner_input")))'` so that the result of `task2` is automatically passed as `arg2` to `task1`.
*   **US-SE-3 (Mapping):** As a developer, I want to run `/task '(map (call aider:automatic (prompt item)) (call plan:generate topic="FeatureX"))'` so that I can generate a list of plan steps (assuming `plan:generate` returns a list) and immediately apply the `aider:automatic` task to each `item` in that list.
*   **US-SE-4 (Dynamic Context):** As a developer, I want to run `/task '(call aider:automatic (prompt "Refactor auth") (files (get_context (query "auth files"))))'` so that the necessary file context for the Aider task is determined dynamically by the `get_context` call and passed to Aider.
*   **US-SE-5 (Error Reporting):** As a developer, if I provide `(call math:add (x 1))` (missing argument) or `(map aider:automatic "not-a-list")`, I want to receive a clear error message indicating the problem within the `/task` result.

**6. Functional Requirements (FRs) - MVP**

*   **FR-SE-1 (REPL/Dispatcher Integration):** The REPL (`_cmd_task`) must detect input starting with `'(` (or dedicated identifier) and pass the S-expression string to the dispatcher. The dispatcher must route this to a new `SExprEvaluator`.
*   **FR-SE-2 (Parser):** An S-expression parser must convert the input string into an internal AST (e.g., nested tuples/lists), supporting lists, symbols, strings, integers, floats, booleans (`#t`/`#f` or `true`/`false`), and `nil`/`null`. Report syntax errors clearly.
*   **FR-SE-3 (Evaluator):** An `SExprEvaluator` must implement `eval(node, environment)` capable of recursively evaluating the AST. The initial `environment` passed to `eval` might be simple (e.g., containing `initial_history` if provided).
*   **FR-SE-4 (Primitive: `call`):**
    *   Syntax: `(call <identifier> <arg>*)` where `<arg>` can be a literal, symbol (error if unbound), or a nested expression (evaluated first). Supports named argument pairs `(key value_expr)`.
    *   Behavior: Evaluate args recursively. Resolve `<identifier>` to Handler Direct Tool or TaskSystem Template. Invoke the target (passing evaluated args). Return the result. Handle optional `(files <list_expression>)` argument for passing context.
*   **FR-SE-5 (Primitive: `map`):**
    *   Syntax: `(map <task_expression> <list_expression>)`
    *   Behavior: Evaluate `<list_expression>` (must result in an iterable list, potentially after JSON parsing if the result is a string). For each `item` in the list: evaluate `<task_expression>` in a temporary environment where the symbol `item` is bound to the current list item value. Return a list of results. Handle errors if `<list_expression>` doesn't yield a list or if an inner evaluation fails (fail-fast initially).
*   **FR-SE-6 (Primitive: `get_context`):**
    *   Syntax: `(get_context <option>*)` where `<option>` is `(<key_symbol> <value_expression>)`.
    *   Behavior: Evaluate value expressions for options (e.g., `query`, `history`). Construct `ContextGenerationInput`. Call `MemorySystem.get_relevant_context_for`. Return the list of file paths (`matches`).
*   **FR-SE-7 (Primitive: `list` - Optional but Recommended):**
    *   Syntax: `(list <expr1> <expr2> ...)`
    *   Behavior: Evaluate each expression and return the results as a standard Python list. Useful for constructing literal lists to pass to `map` or `files`.
*   **FR-SE-8 (Error Handling):** Parser errors, evaluation errors (unbound symbols, primitive misuse, type errors, errors from `call` targets) must be caught and formatted into a `FAILED` `TaskResult` by the dispatcher/evaluator. Error messages should provide context about the failure within the S-expression.
*   **FR-SE-9 (Result):** The final value of the top-level S-expression evaluation becomes the `content` of the `COMPLETE` `TaskResult` (stringified if necessary).

**7. Non-Functional Requirements (NFRs)**

*   **NFR-SE-1 (Performance):** Evaluation should be reasonably performant for moderately nested expressions and maps over small-to-medium lists.
*   **NFR-SE-2 (Reliability):** Parser/evaluator must handle valid inputs correctly and fail predictably with clear errors for invalid inputs/states.
*   **NFR-SE-3 (Usability):** While S-expression syntax is specific, error messages must be helpful for debugging expressions. Documentation is key.
*   **NFR-SE-4 (Maintainability):** Parser and evaluator code should be well-structured and testable.

**8. Design & Technical Approach (High-Level)**

*   Implement `SExprEvaluator`, `SExprEnvironment` (simple version without full lexical scoping needed for `bind`), and potentially a parser module.
*   Implement logic for `call`, `map`, `get_context` (and optionally `list`) primitives within the evaluator.
*   Integrate evaluator into the dispatcher flow.
*   Leverage existing components (`TaskSystem`, `Handler`, `MemorySystem`) as the execution backend for primitives.

**9. Success Metrics & Acceptance Criteria (ACs)**

*   **AC-SE-1:** `/task '(call math:add (x 5) (y 10))'` returns `content` "15".
*   **AC-SE-2:** `/task '(call task1 (arg2 (call task2 "in")))'` executes `task2` then `task1`, passing the result correctly (verified with mocks).
*   **AC-SE-3:** `/task '(map (call math:add (x item) (y 1)) (list 1 2 3))'` returns `content` representing `[2, 3, 4]`. (Requires `list` primitive).
*   **AC-SE-4:** `/task '(call aider:automatic (prompt "Refactor") (files (get_context (query "auth"))))'` successfully calls mocked `get_context` logic and then mocked `aider:automatic` with the files returned by `get_context`.
*   **AC-SE-5:** The workflow `(map (call aider:automatic (prompt item)) (map (call plan:step_to_instructions (step item)) (call plan:generate topic="X")))` executes successfully using mocks for the underlying tasks.
*   **AC-SE-6:** Invalid syntax like `/task '(call math:add (x 1'` returns a `FAILED` TaskResult with a parsing error message.
*   **AC-SE-7:** Runtime errors like `/task '(call non_existent:task)'` or `/task '(map (call ...) "not-a-list")'` return a `FAILED` TaskResult with an evaluation error message.

**10. Open Questions / Future Considerations**

*   Exact S-expression syntax details (e.g., boolean representation, nil representation).
*   Error reporting details (how much context to provide).
*   Need for `bind`, `sequence`, `if`, etc. (Deferred).
*   Concurrency in `map` (Deferred).

